\documentclass[11pt]{article}\usepackage{graphicx, color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.2, 0.2, 0.2}
\newcommand{\hlnumber}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlfunctioncall}[1]{\textcolor[rgb]{0.501960784313725,0,0.329411764705882}{\textbf{#1}}}%
\newcommand{\hlstring}[1]{\textcolor[rgb]{0.6,0.6,1}{#1}}%
\newcommand{\hlkeyword}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlargument}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlcomment}[1]{\textcolor[rgb]{0.180392156862745,0.6,0.341176470588235}{#1}}%
\newcommand{\hlroxygencomment}[1]{\textcolor[rgb]{0.43921568627451,0.47843137254902,0.701960784313725}{#1}}%
\newcommand{\hlformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlassignement}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlpackage}[1]{\textcolor[rgb]{0.588235294117647,0.709803921568627,0.145098039215686}{#1}}%
\newcommand{\hlslot}[1]{\textit{#1}}%
\newcommand{\hlsymbol}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlprompt}[1]{\textcolor[rgb]{0.2,0.2,0.2}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
%\VignetteIndexEntry{A Guide to the FuzzyNumbers Package}
%\VignetteEngine{knitr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage[dvips,a4paper,left=2.5cm,right=2.5cm,foot=1.0cm,
   headheight=1.0cm,top=2.0cm,margin=2.5cm]{geometry}
\linespread{1.1}

\usepackage{fancyhdr}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\selectlanguage{english}
\usepackage{xspace}
\usepackage{lmodern}

\usepackage{amsmath,amssymb,amsfonts}
\RequirePackage{graphicx,verbatim,longtable}
\usepackage{mdwlist}
\usepackage{multirow,multicol}
\usepackage[nottoc]{tocbibind}
\usepackage{rotating}

\newcommand{\email}[1]{\href{mailto:#1}{#1}}
\renewcommand{\emph}[1]{\textsl{#1}}
\newcommand{\indicator}{\text{\bf 1}}
\renewcommand{\Pr}{\mathrm{P}}
\renewcommand{\ln}{\mathrm{ln}\,}

\newcommand{\package}[1]{\textsf{#1}\xspace}
\newcommand{\program}[1]{\textsf{#1}\xspace}
\newcommand{\os}[1]{\textsf{#1}\xspace}
\newcommand{\lang}[1]{\textsf{#1}\xspace}
\newcommand{\Cpp}{\lang{C++}}
\newcommand{\R}{\lang{R}}

\newcommand{\func}[1]{\texttt{\hlfunctioncall{#1}}}
\newcommand{\argument}[1]{\texttt{\hlargument{#1}}}
\newcommand{\str}[1]{\texttt{\hlstring{#1}}}
\newcommand{\key}[1]{{$\langle$\texttt{#1}$\rangle$}\xspace} % skrot klawiszowy

\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}


\usepackage{xcolor}
\definecolor{blue2}{rgb}{0,0.2,0.7}
\definecolor{red2}{rgb}{0.4,0.1,0.1}
\usepackage{colortbl}
\definecolor{navy}{rgb}{0,0.0,0.4}
\definecolor{navy2}{rgb}{0.4,0.1,0.3}
\definecolor{red2}{rgb}{0.6,0.1,0.2}
\definecolor{green2}{rgb}{0.1,0.4,0.2}

\usepackage{hyperref}

\usepackage{caption}
\captionsetup{font=small,labelfont=bf,labelsep=period,justification=centering}
\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Tab.}}


\setlength{\topsep}{1pt} % wpływa m.in. na odstęp dla verbatim
\tolerance=500
\predisplaypenalty=0
\clubpenalty=1000
\widowpenalty=1000



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}



\begin{document}



\begin{center}
{\LARGE\sf A Guide to the \package{FuzzyNumbers} {0.3-devel} Package for \R}

\bigskip
{\large Marek Gagolewski${}^{1,2}$}

${}^{1}$ Systems Research Institute, Polish Academy of Sciences

ul. Newelska 6, 01-447 Warsaw, Poland

${}^{2}$ Rexamine, Email: \texttt{gagolews@rexamine.com}

\href{http://www.rexamine.com/resources/fuzzynumbers/}%
{www.rexamine.com/resources/fuzzynumbers/}

\bigskip
\today



\medskip
\textit{The package, as well as this tutorial, is still in its early
days -- any suggestions and contributions are welcome!}
\end{center}





\bigskip\hrule\bigskip
\tableofcontents




% \definecolor{fgcolor}{gray}{0}
% \renewcommand{\hlnumber}[1]{\textcolor[gray]{0.2}{#1}}%
% \renewcommand{\hlfunctioncall}[1]{\textbf{#1}}%
% \renewcommand{\hlstring}[1]{\textcolor[gray]{0.2}{\textit{#1}}}%
% \renewcommand{\hlkeyword}[1]{\textbf{#1}}%
% \renewcommand{\hlargument}[1]{\textcolor[rgb]{0.2,0.2,0.2}{\textsl{#1}}}%
% \renewcommand{\hlcomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlroxygencomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hlassignement}[1]{\textcolor[gray]{0}{\textbf{#1}}}%
% \renewcommand{\hlpackage}[1]{\textcolor[rgb]{0.59,0.71,0.15}{#1}}%
% \renewcommand{\hlslot}[1]{\textit{#1}}%
% \renewcommand{\hlsymbol}[1]{\textcolor[cmyk]{0,0,0,1}{#1}}%
% \renewcommand{\hlprompt}[1]{\textcolor[cmyk]{0,0,0,0.5}{#1}}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Getting Started}

Fuzzy set theory lets us effectively and quite intuitively represent
imprecise or vague information. Fuzzy numbers (FNs), introduced
by Dubois and Prade in \cite{DuboisPrade1978:opfn}, form a particular
subclass of fuzzy sets of the real line.
Formally, a fuzzy set $A$
with membership function $\mu_A:\mathbb{R}\to[0,1]$
is a fuzzy number, if it possess at least the three following properties:
\begin{itemize}
\item[(i)] it is a normalized fuzzy set,
i.e.~$\mu_A(x_0)=1$ for some $x_0\in\mathbb{R}$,
\item[(ii)] it is fuzzy convex, i.e.~for any $x_1,x_2\in\mathbb{R}$
and $\lambda\in[0,1]$ it holds
$\mu_A(\lambda x_1 + (1-\lambda) x_2) \ge \mu_A(x_1)\wedge \mu_A(x_2)$,
\item[(iii)] the support of $A$ is bounded,
where $\mathrm{supp}(A) = \mathrm{cl}(\{x\in\mathbb{R}: \mu_A(x)>0\})$.
\end{itemize}
Fuzzy numbers play a significant role
in many practical applications
(cf.~\cite{KlirYuan1995:fuzzybook})
since we often describe our knowledge about objects
through numbers, e.g. ``I'm about 180 cm tall''
or ``The rocket was launched between 2 and 3 p.m.''.




\bigskip
\package{FuzzyNumbers} is an Open Source (licensed under GNU LGPL 3)
package for \R -- a free, open sourced software environment
for statistical computing and graphics, which
includes an implementation
of a very powerful and quite popular high-level language called \lang{S}.
and runs on all major operating systems, i.e.~\os{Windows},
\os{Linux}, and \os{MacOS X}\footnote{%
To install \R and/or find some information on the \lang{S} language
please visit \R Project's Homepage at \href{http://www.R-project.org}{www.R-project.org}.
Perhaps you may also wish to install  \program{RStudio},
a convenient development environment for \R.
It is available at \href{http://www.rstudio.com/ide/}{www.rsudio.com/ide}.}.


\package{FuzzyNumbers} has been created in order to deal with fuzzy numbers
conveniently and effectively.
To install latest ``official'' release of the 
package available on \textit{CRAN} we type:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{install.packages}(\hlstring{'FuzzyNumbers'})
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent
Alternatively, we may fetch its current development snapshot
from \href{https://github.com/Rexamine/FuzzyNumbers}{\textit{GitHub}}.


\bigskip
Each session with \package{FuzzyNumbers} should be preceded by
a call to:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{library}(\hlstring{'FuzzyNumbers'}) \hlcomment{# Load the package}
\end{alltt}
\end{kframe}
\end{knitrout}


\bigskip
To view the main page of the manual we type:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{library}(help=\hlstring{'FuzzyNumbers'})
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent
For more information please visit the package's homepage \cite{Gagolewski:FuzzyNumbersHome}.
In case of any problems, comments, or suggestions feel free to contact the author.
Good luck!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{How to Create Instances of Fuzzy Numbers}


\subsection{Arbitrary Fuzzy Numbers}

A fuzzy number $A$ may be defined by specifying
its core, support, and either its left/right side functions
or lower/upper $\alpha$-cut bounds. Please note that many algorithms that
deal with FNs assume we provide at least the latter, i.e.~$\alpha$-cuts.

\subsubsection{Definition by Side Functions}

A fuzzy number $A$ specified by side functions\footnote{Side functions
  are sometimes called branches or shape functions in the literature.}
has a membership function
of the form:
\begin{equation}
\mu_A(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\mathtt{left}\left( \frac{x-\mathtt{a1}}{\mathtt{a2-a1}} \right)  & \text{if } \mathtt{a1} \le x < \mathtt{a2}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\mathtt{right}\left( \frac{x-\mathtt{a3}}{\mathtt{a4-a3}} \right)  & \text{if } \mathtt{a3} < x \le \mathtt{a4}, \\
0 & \text{if } \mathtt{a4}<x, \\
\end{array}\right.
\end{equation}
where $\mathtt{a1},\mathtt{a2},\mathtt{a3},\mathtt{a4}\in\mathbb{R}$,
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
$\mathtt{left}: [0,1]\to[0,1]$ is a nondecreasing function
(called \textit{left side generator of $A$}),
and $\mathtt{right}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{right side generator of $A$}).
In our package, it is assumed that these functions fulfill the conditions
$\mathtt{left}(0)\ge 0$, $\mathtt{left}(1)\le 1$,
$\mathtt{right}(0)\le 1$, and $\mathtt{right}(1)\ge 0$.


Please note that by using side generating functions defined on $[0,1]$
% (instead of the most common approach, i.e.~ordinary side functions
% such that $l_A(x)=\frac{x-\mathtt{a1}}{\mathtt{a2-a1}}$
% and $r_A(x)=\frac{x-\mathtt{a3}}{\mathtt{a4-a3}}$)
we really make (in author's humble opinion) the process of generating
examples for our publications much easier.
A similar concept was used e.g.~in \cite{StefaniniSorini2009:eusflat}
(LR-fuzzy numbers).

\bigskip
An example: a fuzzy number $A_1$ with linear sides
(a trapezoidal fuzzy number, see also Sec.~\ref{Sec:TFNdef}).

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A1 <- \hlfunctioncall{FuzzyNumber}(1, 2, 4, 7,
    left=\hlfunctioncall{function}(x) x,
   right=\hlfunctioncall{function}(x) 1-x
)
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent
This object is an instance of the following \R class:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{class}(A1)
\end{alltt}
\begin{verbatim}
## [1] "FuzzyNumber"
## attr(,"package")
## [1] "FuzzyNumbers"
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
We may print some basic information on $A_1$ by calling \texttt{\func{print}(A1)} or
simply by typing:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A1
\end{alltt}
\begin{verbatim}
## Fuzzy number with:
##    support=[1,7],
##       core=[2,4].
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
To depict $A_1$ we call:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(A1)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/A1ex5} 

}



\end{knitrout}

\end{center}

\noindent
If we would like to generate figures for our publications,
then we will be interested in storing them as PDF files.
This may be done by calling:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{pdf}(\hlstring{'figure1.pdf'}, width=8, height=5) \hlcomment{# create file}
\hlfunctioncall{plot}(A1)
\hlfunctioncall{dev.off}() \hlcomment{# close graphical device and save the file}
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent
Postscript (PS) files are generated by substituting the call
to \func{pdf()} for the call to the \func{postcript()} function.





\paragraph{Remark.}
Assume we are given two fancy side functions $f: [a_1,a_2]=[-4,-2]\to[0,1]$,
and $g: [a_3,a_4]=[-1,10]\to[1,0]$,
for example:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
f <- \hlfunctioncall{splinefun}(\hlfunctioncall{c}(-4,-3.5,-3,-2.2,-2), \hlfunctioncall{c}(0,0.4,0.7,0.9,1), method=\hlstring{'monoH.FC'})
g <- \hlfunctioncall{splinefun}(\hlfunctioncall{c}(-1,0,10), \hlfunctioncall{c}(1,0.5,0), method=\hlstring{'monoH.FC'})
\end{alltt}
\end{kframe}
\end{knitrout}


Let us convert them to side \textit{generating} functions, which shall be
defined on the interval $[0,1]$.
This may easily be done with the \func{convert.side()}
function. It returns a new function that calls
the original one with linearly transformed input.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{convert.side}(f, -4, -2)(\hlfunctioncall{c}(0,1))
\end{alltt}
\begin{verbatim}
## [1] 0 1
\end{verbatim}
\begin{alltt}
\hlfunctioncall{convert.side}(g, -1, 10)(\hlfunctioncall{c}(0,1))
\end{alltt}
\begin{verbatim}
## [1] 1 0
\end{verbatim}
\begin{alltt}
\hlfunctioncall{convert.side}(g, 10, -1)(\hlfunctioncall{c}(0,1)) \hlcomment{# interesting!}
\end{alltt}
\begin{verbatim}
## [1] 0 1
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
These functions may be used to define a fuzzy number,
now with arbitrary support and core.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
B <- \hlfunctioncall{FuzzyNumber}(10,20,20,30,
    left=\hlfunctioncall{convert.side}(f, -4, -2),
   right=\hlfunctioncall{convert.side}(g, -1, 10)
)
\hlfunctioncall{plot}(B, xlab=\hlstring{'$x$'}, ylab=\hlstring{'$\textbackslash{}\textbackslash{}alpha$'})
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ExFconvert4} 

}



\end{knitrout}

\end{center}



\subsubsection{Definition by $\alpha$-cut Bounds}

Alternatively, a fuzzy number $A$ may be defined by specifying 
its $\alpha$-cuts. We have (for $\alpha\in(0,1)$ and 
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$):
\begin{eqnarray}
A_\alpha & := & [A_L(\alpha), A_U(\alpha)]\\
 & = & \big[
   \mathtt{a1}+(\mathtt{a2}-\mathtt{a1})\cdot\mathtt{lower}(\alpha),
   \mathtt{a3}+(\mathtt{a4}-\mathtt{a3})\cdot\mathtt{upper}(\alpha)
\big],
\end{eqnarray}
where $\mathtt{lower}: [0,1]\to[0,1]$ is a nondecreasing function
(called \textit{lower $\alpha$-cut bound generator of $A$}),
and $\mathtt{upper}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{upper bound generator}).
In our package, we assumed that
$\mathtt{lower}(0)=0$, $\mathtt{lower}(1)=1$,
$\mathtt{upper}(0)=1$, and $\mathtt{upper}(1)=0$.

It is easily seen that for $\alpha\in(0,1)$ we have the following
relationship between generating functions:
\begin{eqnarray}
\mathtt{lower}(\alpha) & = & \inf\{x: \mathtt{left}(x)\ge\alpha\}, \\
\mathtt{upper}(\alpha) & = & \sup\{x: \mathtt{right}(x)\ge\alpha\}.
\end{eqnarray}
Moreover, if side generating functions are continuous and strictly
monotonic, then $\alpha$-cut bound generators are their inverses.

\bigskip\noindent
An example:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A1 <- \hlfunctioncall{FuzzyNumber}(1, 2, 4, 7,
    left=\hlfunctioncall{function}(x) x,
   right=\hlfunctioncall{function}(x) 1-x
)
A2 <- \hlfunctioncall{FuzzyNumber}(1, 3, 4, 7,
   lower=\hlfunctioncall{function}(alpha) \hlfunctioncall{pbeta}(alpha, 5, 9), \hlcomment{# CDF of a beta distr.}
   upper=\hlfunctioncall{function}(alpha) \hlfunctioncall{pexp}(1/alpha-1) \hlcomment{# transformed CDF of an exp. distr.}
)
\hlfunctioncall{plot}(A1, col=\hlstring{'blue'})
\hlfunctioncall{plot}(A2, col=\hlstring{'red'}, lty=2, add=TRUE)
\hlfunctioncall{legend}(\hlstring{'topright'}, \hlfunctioncall{c}(\hlfunctioncall{expression}(mu[A1]), \hlfunctioncall{expression}(mu[A2])),
   col=\hlfunctioncall{c}(\hlstring{'blue'}, \hlstring{'red'}), lty=\hlfunctioncall{c}(1,2))
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/alphacutEx2} 

}



\end{knitrout}

\end{center}




\paragraph{Remark.}
The \func{convert.alpha()} function
works similarly to \func{convert.side()}.
This tool, however, scales the output values
of a given function, thus it may be used to create
an alpha-cut generator conveniently.

\subsubsection{Definition with Generating Functions Omitted: Shadowed Sets}

Please note that in the above examples we passed to the
constructor of each \texttt{FuzzyNumber} class instance
either side generating functions or $\alpha$-cut generators.
Let us study what happens, if we omit both of them.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A3 <- \hlfunctioncall{FuzzyNumber}(1, 2, 4, 5)
A3
\end{alltt}
\begin{verbatim}
## Fuzzy number with:
##    support=[1,5],
##       core=[2,4].
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
The object seems to be defined correctly: \R does not make any
complaints. However\dots

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(A3)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/A3deffig2} 

}



\end{knitrout}

\end{center}

\noindent
It turns out that we have obtained a \textit{shadowed set}!
Indeed, this behavior is quite reasonable: we have provided no information
on the ``partial knowledge'' part of our fuzzy number.
In fact, the object has been initialized
with generating functions always returning \texttt{NA}
(\textit{Not-Available} or \textit{any} value).
Does it mean that when we define a FN solely by side generators, we
cannot compute its $\alpha$-cuts? Indeed!

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{alphacut}(A2, 0.5) \hlcomment{# A2 has alpha-cut generators defined}
\end{alltt}
\begin{verbatim}
## [1] 2.733154 5.896362
\end{verbatim}
\begin{alltt}
\hlfunctioncall{alphacut}(A1, 0.5) \hlcomment{# A1 hasn't got them}
\end{alltt}
\begin{verbatim}
## [1] NA NA
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Another example: evaluation of the membership function.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{evaluate}(A1, 6.5) \hlcomment{# A1 has side generators defined}
\end{alltt}
\begin{verbatim}
## [1] 0.1666667
\end{verbatim}
\begin{alltt}
\hlfunctioncall{evaluate}(A2, 6.5) \hlcomment{# A2 hasn't got them}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsection{Using Numeric Approximations of $\alpha$-cut or Side Generators}

The reason for setting  by default
\texttt{NA}s\footnote{To be precise, it's \texttt{NA\_real\_}.}
as return values of generators
(when omitted) is simple. Finding a function inverse numerically
requires lengthy computations and is always done locally
(for a given point, not for ``whole'' the function at once).
\R is not a symbolic mathematical solver.
If we had defined such procedures (it is really easy to do
by using the \texttt{uniroot()} function), then an inexperienced user
would have used it in his/her algorithms and wondered why everything
runs so slow. To get more insight, let us look at the internals of \texttt{A2}:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A2[\hlstring{'lower'}]
\end{alltt}
\begin{verbatim}
## function(alpha) pbeta(alpha, 5, 9)
\end{verbatim}
\begin{alltt}
A2[\hlstring{'upper'}]
\end{alltt}
\begin{verbatim}
## function(alpha) pexp(1/alpha-1)
\end{verbatim}
\begin{alltt}
A2[\hlstring{'left'}]
\end{alltt}
\begin{verbatim}
## function (x) 
## rep(NA_real_, length(x))
## <environment: 0x4ef7fe8>
\end{verbatim}
\begin{alltt}
A2[\hlstring{'right'}]
\end{alltt}
\begin{verbatim}
## function (x) 
## rep(NA_real_, length(x))
## <environment: 0x4ef7fe8>
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Note that all generators are properly vectorized (for
input vectors of length $n$ they always give output of the
same length).
Thus, general rules are as follows.
If you want $\alpha$-cuts (e.g.~for finding
trapezoidal approximations of FNs), specify them.
If you would like to access side functions (by the way,
the \texttt{plot()} function
automatically detects what kind of knowledge we have),
assure they are provided.


However, we we provide some convenient short-cut methods
to \textit{interpolate} generating functions of one type
to get some crude numeric approximations of their inverses.
These are simple wrappers to \R's \func{approxfun()}
(piecewise linear interpolation,
the \str{'{}linear'{}} \argument{method})
and \func{splinefun()} (monotonic
splines: \argument{method}s \str{'{}hyman{}'}
and \str{'{}monoH.FC'{}}; the latter is
default and recommended).
They are available as the \func{approx.invert()}
function\footnote{The
\argument{n} argument, which sets the number of interpolation points,
controls the trade-off between accuracy and computation speed.
Well, world's not ideal, remember that ``any'' is better than ``nothing''
sometimes.}, and may
of course be used on results returned by
\func{convert.alpha()}
and \func{convert.side()}.


\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
l <- \hlfunctioncall{function}(x) \hlfunctioncall{pbeta}(x, 1, 2)
r <- \hlfunctioncall{function}(x) 1-\hlfunctioncall{pbeta}(x, 1, 0.1)
A4 <- \hlfunctioncall{FuzzyNumber}(-2, 0, 0, 2,
   left  = l,
   right = r,
   lower = \hlfunctioncall{approx.invert}(l),
   upper = \hlfunctioncall{approx.invert}(r)
)

x <- \hlfunctioncall{seq}(0,1,length.out=1e5)
\hlfunctioncall{max}(\hlfunctioncall{abs}(\hlfunctioncall{qbeta}(x, 1, 2) - A4[\hlstring{'lower'}](x)))     \hlcomment{# sup-error}
\end{alltt}
\begin{verbatim}
## [1] 0.0001389811
\end{verbatim}
\begin{alltt}
\hlfunctioncall{max}(\hlfunctioncall{abs}(\hlfunctioncall{qbeta}(1-x, 1, 0.1) - A4[\hlstring{'upper'}](x))) \hlcomment{# sup-error}
\end{alltt}
\begin{verbatim}
## [1] 0.0008607773
\end{verbatim}
\end{kframe}
\end{knitrout}




\subsection{Fuzzy Numbers with Discontinuities}\label{Sec:discontdef}

We may also consider fuzzy numbers with discontinuous side
functions or $\alpha$-cut generators.
To avoid extensive numerical integration inaccuracies 
(i.e.~in approximation tasks, see Sec.~\ref{Sec:Approximation})
we use objects from the \texttt{DiscontinuousFuzzyNumber} class.
Further on we will present some examples.


% % or plotting problems....
% 
% % TODO add plot for \texttt{DiscontinuousFuzzyNumber}
% % A1 <- FuzzyNumber(0,1,1,1,
% %          lower=function(a) floor(3*a)/3,
% %          upper=function(a) 1-a
% % ) # no info on discontinuities
% 
% <<ExDiscontinuous>>=
% A2 <- DiscontinuousFuzzyNumber(2,3,3,3,
%          lower=function(a) floor(3*a)/3,
%          upper=function(a) 1-a,
%          discontinuities.lower=c(0, 1/3, 2/3, 1),
%          discontinuities.upper=numeric(0)
% ) # discontinuities info included
% 
% integrateAlpha(A2, "lower", 0, 1)
% integrateAlpha(as.FuzzyNumber(A2), "lower", 0, 1)
% @
% 
% % plots.....
% 
% % integration errors without this info.... (!)
% 
% ... TO BE DONE ....


\subsection{Trapezoidal Fuzzy Numbers}\label{Sec:TFNdef}

A trapezoidal fuzzy number (TFN) is a FN which has linear
side generators and linear $\alpha$-cut bound generators.
To create a trapezoidal fuzzy number $T_1$
with, for example, $\mathrm{core}(T_1)=[1.5,4]$
and $\mathrm{supp}(T_1)=[1,7]$ we call:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
T1 <- \hlfunctioncall{TrapezoidalFuzzyNumber}(1,1.5,4,7)
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent
This object is an instance of the following \R class:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{class}(T1)
\end{alltt}
\begin{verbatim}
## [1] "TrapezoidalFuzzyNumber"
## attr(,"package")
## [1] "FuzzyNumbers"
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
To depict $T_1$ we call:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(T1)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/TrapEx1d} 

}



\end{knitrout}

\end{center}


\bigskip
$T_1$ is (roughly) equivalent to the trapezoidal fuzzy number $A_1$
defined in the previous subsection.
The \texttt{Trapezo\-idalFuzzyNumber}
class inherits all the goodies from the \texttt{FuzzyNumber} class,
but is more specific (guarantees faster computations,
contains more detailed information, etc.).
Of course, in this case the generating functions are known \textit{a priori}
($A_1$ had no $\alpha$-cut generators)
so there is no need to provide them manually
(what is more, this has been disallowed for safety reasons).
Thus, is we wanted to define a trapezoidal FN next time, we would rather
not do it like with $A_1$ but as with $T_1$.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
T1[\hlstring{'lower'}]
\end{alltt}
\begin{verbatim}
## function (alpha) 
## alpha
## <bytecode: 0x3f4cd40>
## <environment: namespace:FuzzyNumbers>
\end{verbatim}
\begin{alltt}
T1[\hlstring{'upper'}]
\end{alltt}
\begin{verbatim}
## function (alpha) 
## 1 - alpha
## <bytecode: 0x3f4cc60>
## <environment: namespace:FuzzyNumbers>
\end{verbatim}
\begin{alltt}
T1[\hlstring{'left'}]
\end{alltt}
\begin{verbatim}
## function (x) 
## x
## <bytecode: 0x3f4cfa8>
## <environment: namespace:FuzzyNumbers>
\end{verbatim}
\begin{alltt}
T1[\hlstring{'right'}]
\end{alltt}
\begin{verbatim}
## function (x) 
## 1 - x
## <bytecode: 0x3f4cec8>
## <environment: namespace:FuzzyNumbers>
\end{verbatim}
\end{kframe}
\end{knitrout}



Thus, we have:
\begin{quote}
\[
\mu_{T_1}(x) = \left\{
\begin{array}{lll}
0      & \text{for} & x\in(-\infty,1), \\
(x-1)/0.5 & \text{for} & x\in[1,1.5), \\
1      & \text{for} & x\in[1.5,4], \\
(7-x)/3 & \text{for} & x\in(4,7], \\
0      & \text{for} & x\in(7,+\infty). \\
\end{array}
\right.
\]

\[
{T_1}_\alpha = [1+0.5\,\alpha, 7-3\,\alpha].
\]

\end{quote}

\noindent
Note that the above equations have been atomatically generated by \package{knitr}
and \LaTeX{} by
calling \texttt{\func{cat}(\func{as.character}(T1, \argument{toLaTeX=}TRUE, \argument{varnameLaTeX=}\str{'{}T\_1'{}}))},
see Sec.~\ref{Sec:Depicting}.

\bigskip\noindent
Trapezoidal fuzzy numbers are among the simplest FNs.
Despite their simplicity, however, they include triangular FNs,
``crisp'' real intervals, and ``crisp'' reals.
Please note that currently no separate classes for these particular TFNs types
are implemented in the package.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{TrapezoidalFuzzyNumber}(1,2,2,3)  \hlcomment{# triangular FN}
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[1,3],
##       core=[2,2].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{TrapezoidalFuzzyNumber}(2,2,3,3)  \hlcomment{# `crisp' interval}
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[2,3],
##       core=[2,3].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{TrapezoidalFuzzyNumber}(5,5,5,5)  \hlcomment{# `crisp' real}
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[5,5],
##       core=[5,5].
\end{verbatim}
\end{kframe}
\end{knitrout}





\subsection{Piecewise Linear Fuzzy Numbers}

Trapezoidal fuzzy numbers are generalized by piecewise linear FNs (PLFNs),
i.e.~fuzzy numbers which side generating functions and $\alpha$-cut
generators are piecewise linear functions.
Each PLFN is given by:
\begin{itemize*}
\item four coefficients $\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$
defining its support and core,
\item the number of ``knots'', \texttt{knot.n}$\ge 0$,
\item a vector of $\alpha$-cut coordinates, \texttt{knot.alpha}, consisting of \texttt{knot.n} elements $\in[0,1]$,
\item a nondecreasingly sorted vector \texttt{knot.left} consisting of \texttt{knot.n} elements $\in[\mathtt{a1},\mathtt{a2}]$,
defining interpolation points for the left side function, and
\item a nondecreasingly sorted vector \texttt{knot.right} consisting of \texttt{knot.n} elements $\in[\mathtt{a2},\mathtt{a3}]$,
defining interpolation points for the right side function.
\end{itemize*}

If \texttt{knot.n}$\ge 1$, then the membership function of
a piecewise linear fuzzy number $P$ is defined as:
\begin{equation}
\mu_P(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\alpha_i+(\alpha_{i+1}-\alpha_i) \left(\frac{x-l_i}{l_{i+1}-l_i}\right)  & \text{if }\ \, l_i \le x < l_{i+1}\\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\alpha_{n-i+2}+(\alpha_{n-i+3}-\alpha_{n-i+2}) \left(1-\frac{x-r_i}{r_{i+1}-r_i}\right)  & \text{if}\ \, r_i < x \le r_{i+1} \\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
0 & \text{if } \mathtt{a4}<x,
\end{array}\right.
\end{equation}
and its $\alpha$-cuts for $\alpha\in[\alpha_i, \alpha_{i+1}]$
(for some $i\in\{1,\dots,n+1\}$) are given by:
\begin{eqnarray}
P_L(\alpha) & = & l_i+(l_{i+1}-l_i)\left(\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right), \\
P_U,(\alpha) & = & r_{n-i+2}+(r_{n-i+3}-r_{n-i+2})\left(1-\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right),
\end{eqnarray}
where $n=\mathtt{knot.n}$, $(l_1,\dots,l_{n+2}) = (\mathtt{a1},\mathtt{knot.left},\mathtt{a2})$,
$(r_1,\dots,r_{n+2}) = (\mathtt{a3},\mathtt{knot.right},\mathtt{a4})$,
and $(\alpha_1,\dots,\alpha_{n+2})=(0,\mathtt{knot.alpha},1)$.

\bigskip
PLFNs in our package are represented by the \texttt{PiecewiseLinearFuzzyNumber} class.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
P1 <- \hlfunctioncall{PiecewiseLinearFuzzyNumber}(1, 2, 3, 4,
   knot.n=1, knot.alpha=0.25, knot.left=1.5, knot.right=3.25)
\hlfunctioncall{class}(P1)
\end{alltt}
\begin{verbatim}
## [1] "PiecewiseLinearFuzzyNumber"
## attr(,"package")
## [1] "FuzzyNumbers"
\end{verbatim}
\begin{alltt}
P1
\end{alltt}
\begin{verbatim}
## Piecewise linear fuzzy number with 1 knot(s),
##    support=[1,4],
##       core=[2,3].
\end{verbatim}
\begin{alltt}
P2 <- \hlfunctioncall{PiecewiseLinearFuzzyNumber}(1, 2, 3, 4,
   knot.n=2, knot.alpha=\hlfunctioncall{c}(0.25,0.6),
   knot.left=\hlfunctioncall{c}(1.5,1.8), knot.right=\hlfunctioncall{c}(3.25, 3.5))
P2
\end{alltt}
\begin{verbatim}
## Piecewise linear fuzzy number with 2 knot(s),
##    support=[1,4],
##       core=[2,3].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{plot}(P1, type=\hlstring{'b'}, from=0, to=5, xlim=\hlfunctioncall{c}(0.5,4.5))
\hlfunctioncall{plot}(P2, type=\hlstring{'b'}, col=2, lty=2, pch=2, add=TRUE, from=0, to=5)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/PLFNEx1b} 

}



\end{knitrout}

\end{center}

The following operators return matrices with all knots of a PLFN.
Each of them have three columns, in order: $\alpha$-cuts,
left side coordinates, and right side coordinates.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
P1[\hlstring{'knots'}]
\end{alltt}
\begin{verbatim}
##        alpha left right
## knot_1  0.25  1.5  3.25
\end{verbatim}
\begin{alltt}
P1[\hlstring{'allknots'}] \hlcomment{# including a1,a2,a3,a4}
\end{alltt}
\begin{verbatim}
##        alpha left right
## supp    0.00  1.0  4.00
## knot_1  0.25  1.5  3.25
## core    1.00  2.0  3.00
\end{verbatim}
\end{kframe}
\end{knitrout}


We have, for example:
\begin{quote}
\[
\mu_{P_1}(x) = \left\{
\begin{array}{lll}
0      & \text{for} & x\in(-\infty,1), \\
0+0.25\,(x+1)/0.5 & \text{for} & x\in[1,1.5), \\
0.25+0.75\,(x+1.5)/0.5 & \text{for} & x\in[1.5,2), \\
1      & \text{for} & x\in[2,3], \\
0.25+0.75\,(3.25-x)/0.25 & \text{for} & x\in[3,3.25), \\
0+0.25\,(4-x)/0.75 & \text{for} & x\in[3.25,4), \\
0      & \text{for} & x\in(4,+\infty). \\
\end{array}
\right.
\]

\[
{P_1}_\alpha = [{P_1}_L(\alpha), {P_1}_U(\alpha)],
\]
where
\[
{P_1}_L(\alpha) = \left\{
\begin{array}{lll}
1+0.5\,(\alpha-0)/0.25 & \text{for} & \alpha\in[0,0.25], \\
1.5+0.5\,(\alpha-0.25)/0.75 & \text{for} & \alpha\in[0.25,1], \\
\end{array}
\right.
\]
\[
{P_1}_U(\alpha) = \left\{
\begin{array}{lll}
3.25+0.75\,(0.25-\alpha)/0.25 & \text{for} & \alpha\in[0,0.25], \\
3+0.25\,(1-\alpha)/0.75 & \text{for} & \alpha\in[0.25,1]. \\
\end{array}
\right.
\]

\end{quote}

\bigskip
If you want to obtain a PLFN with equally distributed knots, then
you may use the more convenient version of
the \func{PiecewiseLinearFuzzyNumber()} function.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{PiecewiseLinearFuzzyNumber}(knot.left=\hlfunctioncall{c}(0,0.5,0.7,1),
                           knot.right=\hlfunctioncall{c}(2,2.2,2.4,3))[\hlstring{'allknots'}]
\end{alltt}
\begin{verbatim}
##            alpha left right
## supp   0.0000000  0.0   3.0
## knot_1 0.3333333  0.5   2.4
## knot_2 0.6666667  0.7   2.2
## core   1.0000000  1.0   2.0
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Note that if $a_1,\dots, a_4$ are omitted, then they are taken
from \argument{knot.left} and \argument{knot.right}
(their lengths should then be equal to \argument{knot.n}+2).

\bigskip
If \texttt{knot.n} is equal to 0 or all left and right knots lie on common lines,
then a PLFN reduces to a TFN.
Please note that, however, the \texttt{TrapezoidalFuzzyNumber} class
does not inherit from \texttt{PiecewiseLinearFuzzyNumber}
for efficiency reasons.
If, however, we wanted to convert an object
of the first mentioned class to the other,
we would do that by calling:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
alpha <- \hlfunctioncall{c}(0.3, 0.5, 0.7)
P3 <- \hlfunctioncall{as.PiecewiseLinearFuzzyNumber}(
   \hlfunctioncall{TrapezoidalFuzzyNumber}(1,2.5,4,7),
         knot.n=3, knot.alpha=alpha)
P3
\end{alltt}
\begin{verbatim}
## Piecewise linear fuzzy number with 3 knot(s),
##    support=[1,7],
##       core=[2.5,4].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{plot}(P3, type=\hlstring{'b'}, from=-1, to=9, xlim=\hlfunctioncall{c}(0,8))
\hlfunctioncall{abline}(h=alpha, col=\hlstring{'gray'}, lty=2)
\hlfunctioncall{abline}(v=P3[\hlstring{'knot.left'}], col=\hlstring{'gray'}, lty=3)
\hlfunctioncall{abline}(v=P3[\hlstring{'knot.right'}], col=\hlstring{'gray'}, lty=3)
\hlfunctioncall{text}(7.5, alpha, \hlfunctioncall{sprintf}(\hlstring{'a=%g'}, alpha), pos=3)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/PLFNEx2b} 

}



\end{knitrout}

\end{center}

\noindent
More generally, each PLFN or TFN may be converted
to a direct \texttt{FuzzyNumber} class instance if needed
(hope we will never not).

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(\hlfunctioncall{as.FuzzyNumber}(P3))
\end{alltt}
\begin{verbatim}
## Fuzzy number with:
##    support=[1,7],
##       core=[2.5,4].
\end{verbatim}
\end{kframe}
\end{knitrout}


On the other hand, to ``convert'' (with possible information loss)
more general FNs to TFNs or PLFNs, we may use the approximation
procedures described in Sec.~\ref{Sec:Approximation}.



\subsection{Fuzzy Numbers with Sides Given by Power Functions}\label{Sec:powerdef}

Fuzzy numbers which sides are given by power functions
are defined with four coefficients $\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
and parameters $\mathtt{p.left},\mathtt{p.right}>0$ which determine
exponets for the side functions:
\begin{eqnarray}
\mathtt{left}(x)&=&x^{\mathtt{p.left}},\\
\mathtt{right}(x)&=&(1-x)^{\mathtt{p.right}}.
\end{eqnarray}
We also have:
\begin{eqnarray}
\mathtt{lower}(\alpha)&=&\sqrt[\mathtt{p.left}]{\alpha},\\
\mathtt{upper}(\alpha)&=&1-\sqrt[\mathtt{p.right}]{\alpha}.
\end{eqnarray}
These fuzzy numbers are another natural generalization of trapezoidal FNs.

An example:
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
X <- \hlfunctioncall{PowerFuzzyNumber}(-3, -1, 1, 3, p.left=2, p.right=0.1)
\hlfunctioncall{class}(X)
\end{alltt}
\begin{verbatim}
## [1] "PowerFuzzyNumber"
## attr(,"package")
## [1] "FuzzyNumbers"
\end{verbatim}
\begin{alltt}
X
\end{alltt}
\begin{verbatim}
## Fuzzy number given by power functions, and:
##    support=[-3,3],
##       core=[-1,1].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{plot}(X)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/PowerEx1b} 

}



\end{knitrout}

\end{center}

We have:
\begin{quote}
\[
\mu_{X}(x) = \left\{
\begin{array}{lll}
0      & \text{for} & x\in(-\infty,-3), \\
((x+3)/2)^{2} & \text{for} & x\in[-3,-1), \\
1      & \text{for} & x\in[-1,1], \\
((3-x)/2)^{0.1} & \text{for} & x\in(1,3], \\
0      & \text{for} & x\in(3,+\infty), \\
\end{array}
\right.
\]

\[
{X}_\alpha = [-3+2\,\alpha^{0.5}, 1+2\,(1-\alpha^{10})].
\]

\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Depicting Fuzzy Numbers}\label{Sec:Depicting}


To depict FNs we use the \texttt{plot()} method,
which uses similar parameters as the \R-built-in
\texttt{curve()} function. If you are new to \R, you may wish
to read the manual on the most popular graphical routines by
calling \texttt{?plot}, \texttt{?plot.default}, \texttt{?curve},
\texttt{?abline}, \texttt{?par}, \texttt{?lines}, \texttt{?points},
\texttt{?legend}, \texttt{?text} (some of these functions have
already been called in this tutorial).

Let us consider the following FN:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{FuzzyNumber}(-5, 3, 6, 20,
    left=\hlfunctioncall{function}(x) \hlfunctioncall{pbeta}(x,0.4,3),
   right=\hlfunctioncall{function}(x) 1-x^(1/4),
   lower=\hlfunctioncall{function}(alpha) \hlfunctioncall{qbeta}(alpha,0.4,3),
   upper=\hlfunctioncall{function}(alpha) (1-alpha)^4
)
\hlfunctioncall{plot}(A)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/depicting1b} 

}



\end{knitrout}

\end{center}

\paragraph{Plotting issues: discretization.}
Side functions or $\alpha$-cut bounds of objects of the \texttt{FuzzyNumber}
class (not including its derivatives) when plotted are naively
approximated by piecewise linear functions with equidistant knots
at one of the axes. Therefore, if we probe them
at too few points, we may obtain very rough graphical representations.
To control the number of points at which the interpolation takes place,
we use the \texttt{n} parameter (which defaults to \texttt{101} = quite
accurate).

All three calls to the \texttt{plot()} method below depict the membership
function of the same fuzzy number, but with different accuracy.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(A, n=3, type=\hlstring{'b'})
\hlfunctioncall{plot}(A, n=6, add=TRUE,  lty=2, col=2, type=\hlstring{'b'}, pch=2)
\hlfunctioncall{plot}(A, n=101, add=TRUE, lty=4, col=4) \hlcomment{# default n}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/depicting1d} 

}



\end{knitrout}

\end{center}




\paragraph{Making use of different generating functions' types.}
Please note (if you have not already) that to draw the membership
function we do not need to provide necessarily the FN with side generators:
the $\alpha$-cuts will also suffice.
The function is smart enough to detect the internal
representation of the FN and use the kind representation it has.
It both types of generators are given then side functions are used.
If we want to, for some reasons, use $\alpha$-cuts, then we may do as follows:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(A, n=3, at.alpha=\hlfunctioncall{numeric}(0), type=\hlstring{'b'}) \hlcomment{# use alpha-cuts}
\hlfunctioncall{plot}(A, n=3, type=\hlstring{'b'}, col=2, lty=2, pch=2, add=TRUE) \hlcomment{# use sides}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/depicting1f} 

}



\end{knitrout}

\end{center}

\bigskip
We may also illustrate an $\alpha$-cut representation of a fuzzy number:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{plot}(A, draw.alphacuts=TRUE)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/depicting1h} 

}



\end{knitrout}

\end{center}


\paragraph{Conversion to \LaTeX.}
Another way to depict a FN is to\dots give a mathematical expression
which defines it.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{cat}(\hlfunctioncall{as.character}(A, toLaTeX=TRUE, varnameLaTeX=\hlstring{'A'}))
\end{alltt}
\end{kframe}
\end{knitrout}


\noindent This gives the following \LaTeX{} code\dots
\begin{verbatim}
\[
\mu_{A}(x) = \left\{
\begin{array}{lll}
0      & \text{for} & x\in(-\infty,-5), \\
l_{A}(x) & \text{for} & x\in[-5,3), \\
1      & \text{for} & x\in[3,6], \\
r_{A}(x) & \text{for} & x\in(6,20], \\
0      & \text{for} & x\in(20,+\infty), \\
\end{array}
\right.
\]
where $l_{A}=\mathtt{left}_A((x+5)/8)$,
$r_{A}=\mathtt{right}_A((x-6)/14)$.

\[
{A}_\alpha = [{A}_L(\alpha), {A}_U(\alpha)],
\]
where ${A}_L(\alpha)=-5+8\,\mathtt{lower}_{A}(\alpha)$,
${A}_U(\alpha)=6+14\,\mathtt{upper}_{A}(\alpha)$.

\end{verbatim}

\noindent \dots and, after compiling:

\begin{quote}
\[
\mu_{A}(x) = \left\{
\begin{array}{lll}
0      & \text{for} & x\in(-\infty,-5), \\
l_{A}(x) & \text{for} & x\in[-5,3), \\
1      & \text{for} & x\in[3,6], \\
r_{A}(x) & \text{for} & x\in(6,20], \\
0      & \text{for} & x\in(20,+\infty), \\
\end{array}
\right.
\]
where $l_{A}=\mathtt{left}_A((x+5)/8)$,
$r_{A}=\mathtt{right}_A((x-6)/14)$.

\[
{A}_\alpha = [{A}_L(\alpha), {A}_U(\alpha)],
\]
where ${A}_L(\alpha)=-5+8\,\mathtt{lower}_{A}(\alpha)$,
${A}_U(\alpha)=6+14\,\mathtt{upper}_{A}(\alpha)$.

\end{quote}

\noindent
The code may of course be modified to suit your needs.

\paragraph{Tuning your figures.}
Finally, we leave you with a quite complex example from one of our papers:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
X <- \hlfunctioncall{PiecewiseLinearFuzzyNumber}(0, 1, 2, 5, knot.n=1,
   knot.alpha=0.6, knot.left=0.3, knot.right=4)

\hlfunctioncall{plot.default}(NA, xlab=\hlstring{'$x$'}, ylab=\hlstring{'$\textbackslash{}\textbackslash{}\hlfunctioncall{mu_S}(x)$'},
   xlim=\hlfunctioncall{c}(-0.3,5.3), ylim=\hlfunctioncall{c}(0,1)) \hlcomment{# empty window}

xpos <- \hlfunctioncall{c}(X[\hlstring{'a1'}], X[\hlstring{'knot.left'}],  X[\hlstring{'a2'}],
          X[\hlstring{'a3'}], X[\hlstring{'knot.right'}], X[\hlstring{'a4'}])
xlab <- \hlfunctioncall{c}(\hlstring{'$s_1$'}, \hlstring{'$s_2$'}, \hlstring{'$s_3$'},
          \hlstring{'$s_4$'}, \hlstring{'$s_5$'}, \hlstring{'$s_6$'})
\hlfunctioncall{abline}(v=xpos, col=\hlstring{'gray'}, lty=3)
\hlfunctioncall{text}(xpos, 1.05, xlab, pos=3, xpd=TRUE)

\hlfunctioncall{abline}(h=\hlfunctioncall{c}(0, X[\hlstring{'knot.alpha'}], 1), col=\hlstring{'gray'}, lty=2)
\hlfunctioncall{text}(5.55, X[\hlstring{'knot.alpha'}], \hlfunctioncall{sprintf}(\hlstring{'$\textbackslash{}\textbackslash{}alpha_0$'}), pos=4, xpd=TRUE)

\hlfunctioncall{plot}(X, add=TRUE, type=\hlstring{'l'}, from=-1, to=6)
\hlfunctioncall{plot}(X, add=TRUE, type=\hlstring{'p'}, from=-1, to=6)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/depicting2b} 

}



\end{knitrout}

\end{center}

\noindent
Please note that we use \TeX{} commands in plot labels.
They are interpreted by the \texttt{tikzDevice} package for \R
to generate beautiful figures, but setting this all up requires
higher level of skills\dots and patience.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Basic Computations on and Characteristics of Fuzzy Numbers}


In this section we consider the following FN:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{FuzzyNumber}(-5, 3, 6, 20,
    left=\hlfunctioncall{function}(x) \hlfunctioncall{pbeta}(x,0.4,3),
   right=\hlfunctioncall{function}(x) 1-x^(1/4),
   lower=\hlfunctioncall{function}(alpha) \hlfunctioncall{qbeta}(alpha,0.4,3),
   upper=\hlfunctioncall{function}(alpha) (1-alpha)^4
)
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection{Support and Core, and Other $\alpha$-cuts}

The support of $A$, i.e.~$\mathrm{supp}(A)=[\mathtt{a1}, \mathtt{a4}]$,
may be obtained by calling:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{supp}(A)
\end{alltt}
\begin{verbatim}
## [1] -5 20
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
We get the core of $A$, i.e.~$\mathrm{core}(A)=[\mathtt{a2}, \mathtt{a3}]$,
with:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{core}(A)
\end{alltt}
\begin{verbatim}
## [1] 3 6
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
To compute arbitrary $\alpha$-cuts we use:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{alphacut}(A, 0) \hlcomment{# same as \hlfunctioncall{supp}(A) (if alpha-cut generators are defined)}
\end{alltt}
\begin{verbatim}
## [1] -5 20
\end{verbatim}
\begin{alltt}
\hlfunctioncall{alphacut}(A, 1) \hlcomment{# same as \hlfunctioncall{core}(A)}
\end{alltt}
\begin{verbatim}
## [1] 3 6
\end{verbatim}
\begin{alltt}
\hlfunctioncall{alphacut}(A, \hlfunctioncall{c}(0,0.5,1))
\end{alltt}
\begin{verbatim}
##           [,1]   [,2]
## [1,] -5.000000 20.000
## [2,] -4.583591  6.875
## [3,]  3.000000  6.000
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Note that if we request to compute more than one $\alpha$-cut at once, then
a matrix with 2 columns (instead of a numeric vector of length 2) is returned.
The \texttt{alphacut()} method may only be used when $\alpha$-cut generators are
provided by the user during the declaration of $A$, even for $\alpha=0$
or $\alpha=1$.

\subsection{Evaluation of the Membership Function}

If side generators are defined, we may calculate
the values of the membership function at different points by calling:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{evaluate}(A, 1)
\end{alltt}
\begin{verbatim}
## [1] 0.9960291
\end{verbatim}
\begin{alltt}
\hlfunctioncall{evaluate}(A, \hlfunctioncall{c}(-3,0,3))
\end{alltt}
\begin{verbatim}
## [1] 0.8371139 0.9855322 1.0000000
\end{verbatim}
\begin{alltt}
\hlfunctioncall{evaluate}(A, \hlfunctioncall{seq}(-1, 2, by=0.5))
\end{alltt}
\begin{verbatim}
## [1] 0.9624800 0.9760168 0.9855322 0.9919531 0.9960291 0.9983815 0.9995357
\end{verbatim}
\end{kframe}
\end{knitrout}


% \noindent
% As wee see, this method needs a numeric vector (possibly of length 1)
% as its second parameter.


\subsection{``Typical'' Value}


Let us first introduce the notion of the \textit{expected interval} of $A$
\cite{DuboisPrade1987:meanfn}.
\begin{eqnarray}
\mathrm{EI}(A) & := & [\mathrm{EI}_L(A), \mathrm{EI}_U(A)] \\
               & = & \left[ \int_0^1 A_L(\alpha)\,d\alpha, \int_0^1 A_U(\alpha)\,d\alpha \right].
\end{eqnarray}

\noindent
To compute the expected interval of $A$ we call:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{expectedInterval}(A)
\end{alltt}
\begin{verbatim}
## [1] -4.058824  8.800000
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Please note that in case of objects of
the \texttt{FuzzyNumber} class the expected interval is approximated
by numerical integration. This method calls the \texttt{integrate()} function
and its accuracy (quite fine by default)
may be controlled by the \texttt{subdivisions},
\texttt{rel.tol}, and \texttt{abs.tol} parameters
(call \texttt{?integrate} for more details).
On the other hand, for TFNs and PLFs this method returns exact results.

\bigskip
The midpoint of the expected interval is called the \textit{expected value}
of a fuzzy number. It is given by:
\begin{equation}
\mathrm{EV}(A) := \frac{\mathrm{EI}_L(A) + \mathrm{EI}_U(A)}{2}.
\end{equation}

\noindent
Let us calculate $\mathrm{EV}(A)$.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{expectedValue}(A)
\end{alltt}
\begin{verbatim}
## [1] 2.370588
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Note that this method uses a call to \texttt{expectedInterval(A)},
thus in case of \texttt{FuzzyNumber} class instances it also uses
numerical approximation.

Sometimes a generalization of the expected value,
called \textit{weighted expected value}, is useful.
For given $w\in[0,1]$ it is defined as:
\begin{equation}
\mathrm{EV}_w(A) := (1-w)\mathrm{EI}_L(A) + w\mathrm{EI}_U(A).
\end{equation}
It is easily seen that $\mathrm{EV}_{0.5}(A)=\mathrm{EV}(A)$.

\noindent
Some examples:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{weightedExpectedValue}(A, 0.5) \hlcomment{# equivalent to \hlfunctioncall{expectedValue}(A)}
\end{alltt}
\begin{verbatim}
## [1] 2.370588
\end{verbatim}
\begin{alltt}
\hlfunctioncall{weightedExpectedValue}(A, 0.25)
\end{alltt}
\begin{verbatim}
## [1] -0.8441176
\end{verbatim}
\end{kframe}
\end{knitrout}


\bigskip
The \textit{value} of $A$ \cite{DelgadoETAL1998:canonicalfn} is defined by:
\begin{equation}
\mathrm{val}(A) := \int_0^1 \alpha\left(A_L(\alpha)+A_U(\alpha)\right)\,d\alpha.
\end{equation}

\noindent
It may be calculated by calling:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{value}(A)
\end{alltt}
\begin{verbatim}
## [1] 1.736177
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent
Please note that the expected value or  value
may be used for example to ``defuzzify'' $A$.


\subsection{Measures of ``Nonspecificity''}


The \textit{width} of $A$ \cite{Chanas2001:intervapproxfn} is defined as:
\begin{equation}
\mathrm{width}(A) := \mathrm{EI}_U(A) - \mathrm{EI}_L(A).
\end{equation}

\noindent
An example:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{width}(A)
\end{alltt}
\begin{verbatim}
## [1] 12.85882
\end{verbatim}
\end{kframe}
\end{knitrout}


\bigskip
The \textit{ambiguity} of $A$ \cite{DelgadoETAL1998:canonicalfn} is defined as:
\begin{equation}
\mathrm{amb}(A) := \int_0^1 \alpha\left(A_U(\alpha)-A_L(\alpha)\right)\,d\alpha.
\end{equation}

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{ambiguity}(A)
\end{alltt}
\begin{verbatim}
## [1] 5.197157
\end{verbatim}
\end{kframe}
\end{knitrout}


\bigskip
Additionally, to express ``nonspecificity'' of a fuzzy number
we may use e.g.~the width of its support:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{diff}(\hlfunctioncall{supp}(A))
\end{alltt}
\begin{verbatim}
## [1] 25
\end{verbatim}
\end{kframe}
\end{knitrout}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Operations on Fuzzy Numbers}\label{Sec:Operations}

\subsection{Arithmetic Operations}

The basic binary arithmetic operations for FNs are often defined
by means of the so-called extension principle 
(see \cite{KlirYuan1995:fuzzybook})
and interval arithmetic.
For each $\alpha\in[0,1]$:
\[
   (A \circledast B)_\alpha
   = A_\alpha \circledast B_\alpha,
\]
where $\circledast=+,-,*$ or $/$,
and $A,B$ are arbitrary FNs.

For example, we define the sum $A+B$  for every
$\alpha \in \lbrack 0,1]$ as:%
\[
\left( A+B\right) _{\alpha }=A_{\alpha }+B_{\alpha }=\left[ A_{L}\left(
\alpha \right) +B_{L}\left( \alpha \right) ,A_{U}\left( \alpha \right)
+B_{U}\left( \alpha \right) \right],
\]%
see \cite{DuboisPrade1978:opfn,DiamondKloeden1994:metricspacesfs}.
Moreover, for $\lambda \in \mathbb{R}$,
the scalar multiplication is given by:
\[
\left( \lambda \cdot A\right) _{\alpha }=\lambda A_{\alpha }=\left\{ 
\begin{array}{ll}
\left[ \lambda A_{L}\left( \alpha \right) ,\lambda A_{U}\left( \alpha
\right) \right] , & \text{if }\lambda \geq 0, \\ 
\left[ \lambda A_{U}\left( \alpha \right) ,\lambda A_{L}\left( \alpha
\right) \right] , & \text{if }\lambda <0,%
\end{array}%
\right. 
\]%
for each $\alpha \in \lbrack 0,1]$.



In the \package{FuzzyNumbers} package we have defined
the \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/} operators,
which implements the basic arithmetic operations
as defined in \cite{KlirYuan1995:fuzzybook}.


\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{TrapezoidalFuzzyNumber}(0, 1, 1, 2)
B <- \hlfunctioncall{TrapezoidalFuzzyNumber}(1, 2, 2, 3)
\hlfunctioncall{plot}(A, xlim=\hlfunctioncall{c}(0,6), xlab=\hlstring{'$x$'}, ylab=\hlstring{'$\textbackslash{}\textbackslash{}alpha$'})
\hlfunctioncall{plot}(B, add=TRUE, col=2, lty=2)
\hlfunctioncall{plot}(A+B, add=TRUE, col=4, lty=4)
\hlfunctioncall{legend}(\hlstring{'topright'}, \hlfunctioncall{c}(\hlstring{'$A$'}, \hlstring{'$B$'}, \hlstring{'$A+B$'}), lty=\hlfunctioncall{c}(1,2,4), col=\hlfunctioncall{c}(1,2,4))
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=4.5in]{figures-knitr/addition} 

}



\end{knitrout}



Currently all the operations are available
for piecewise linear FNs only,
and addition and scalar multiplication
is additionally implemented for trapezoidal FNs.
Note that the computer arithmetic has anyway
a discrete nature, and a PLFN with large number
of knots often approximates (cf.~Sec.~\ref{Sec:Approximation})
an arbitrary FN sufficiently well.
The computations are always exact (well, up to the computer
floating-point arithmetic errors) at knots.

In theory the class of PLFNs is not closed
under the operations \texttt{*} and \texttt{/}.
However, if you operate on a large number of knots,
the results should be satisfactory.



\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{piecewiseLinearApproximation}(\hlfunctioncall{PowerFuzzyNumber}(1,2,3,4,p.left=2,p.right=0.5),
   method=\hlstring{"Naive"}, knot.n=20)
B <- \hlfunctioncall{piecewiseLinearApproximation}(\hlfunctioncall{PowerFuzzyNumber}(2,3,4,5,p.left=0.1,p.right=3),
   method=\hlstring{"Naive"}, knot.n=40)
A+A \hlcomment{# the same as 2*A}
\end{alltt}
\begin{verbatim}
## Piecewise linear fuzzy number with 20 knot(s),
##    support=[2,8],
##       core=[4,6].
\end{verbatim}
\begin{alltt}
A+B \hlcomment{# note the number of knots has increased}
\end{alltt}
\begin{verbatim}
## Piecewise linear fuzzy number with 60 knot(s),
##    support=[3,9],
##       core=[5,7].
\end{verbatim}
\end{kframe}
\end{knitrout}




\subsection{Applying Functions}


To apply a monotonic transformation on a piecewise linear fuzzy number
(using the extension principle) we call \func{fapply()}.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{as.PiecewiseLinearFuzzyNumber}(\hlfunctioncall{TrapezoidalFuzzyNumber}(0,1,2,3), knot.n=100)
\hlfunctioncall{plot}(\hlfunctioncall{fapply}(A, \hlfunctioncall{function}(x) \hlfunctioncall{log}(x+1)^0.5), xlab=\hlstring{'$x$'}, ylab=\hlstring{'$\textbackslash{}\textbackslash{}alpha$'})
\hlfunctioncall{legend}(\hlstring{'topleft'}, \hlstring{'$\textbackslash{}\textbackslash{}sqrt\{\textbackslash{}\textbackslash{}\hlfunctioncall{log}(A+1)\}$'}, lty=1)
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=4.5in]{figures-knitr/fapply} 

}



\end{knitrout}


\noindent
The operation being applied should be a properly
vectorized \R function object.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Approximation of Fuzzy Numbers}\label{Sec:Approximation}


\subsection{Metrics in the Space of Fuzzy Numbers}

It seems that the most suitable metric for approximation problems
is an extension of the Euclidean ($L_2$) distance
(cf.~\cite{Grzegorzewski1998:metricsordersfn}), $d$, defined by the equation:
\begin{equation}
d^2(A,B) = \int_0^1 \left(A_L(\alpha)-B_L(\alpha)\right)^2\,d\alpha
         + \int_0^1 \left(A_U(\alpha)-B_U(\alpha)\right)^2\,d\alpha.
\end{equation}

% TO BE DONE...

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
T1 <- \hlfunctioncall{TrapezoidalFuzzyNumber}(-5, 3, 6, 20)
T2 <- \hlfunctioncall{TrapezoidalFuzzyNumber}(-4, 4, 7, 21)
\hlfunctioncall{distance}(T1, T2, type=\hlstring{'Euclidean'}) \hlcomment{# L2 distance /default/}
\end{alltt}
\begin{verbatim}
## [1] 1.414214
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(T1, T2, type=\hlstring{'EuclideanSquared'}) \hlcomment{# Squared L2 distance}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}


Types available (argument \texttt{type}): \texttt{Euclidean} (default),
\texttt{EuclideanSquared}...





\subsection{Approximation by Trapezoidal Fuzzy Numbers}

TO BE DONE... Problem statement...
%
Given a fuzzy number $A$ we seek for a trapezoidal
fuzzy number $\mathcal{T}(A)$....

In this subsection we will use the following fuzzy number $A$
for the sake of illustration:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{FuzzyNumber}(-5, 3, 6, 20,
   left=\hlfunctioncall{function}(x) \hlfunctioncall{pbeta}(x,0.4,3),
   right=\hlfunctioncall{function}(x) 1-x^(1/4),
   lower=\hlfunctioncall{function}(alpha) \hlfunctioncall{qbeta}(alpha,0.4,3),
   upper=\hlfunctioncall{function}(alpha) (1-alpha)^4
)
\end{alltt}
\end{kframe}
\end{knitrout}



\subsubsection{Na\'{i}ve Approximation}

The \texttt{'Naive'} method generates a trapezoidal FN with the same
core and support as $A$.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(T1 <- \hlfunctioncall{trapezoidalApproximation}(A, method=\hlstring{'Naive'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[-5,20],
##       core=[3,6].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(A, T1)
\end{alltt}
\begin{verbatim}
## [1] 5.761482
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxExA_naive2} 

}



\end{knitrout}

\end{center}



\subsubsection{$L_2$-nearest Approximation}

% $L_2$ distance....

The \texttt{'NearestEuclidean'} method
gives the nearest $L_2$-approximation of $A$
\cite[Corollary 8]{Ban2009:nearestfnrev}.

% TO BE DONE...

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(T2 <- \hlfunctioncall{trapezoidalApproximation}(A, method=\hlstring{'NearestEuclidean'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[-5.85235,14.4],
##       core=[-2.26529,3.2].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(A, T2)
\end{alltt}
\begin{verbatim}
## [1] 1.98043
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxExA_naiveL2n2} 

}



\end{knitrout}

\end{center}


\subsubsection{Expected Interval Preserving Approximation}


The \texttt{'ExpectedIntervalPreserving'} method
gives the nearest $L_2$-approximation of $A$
preserving the expected interval \cite{Ban2008:approxpresexpint,Grzegorzewski2010:trapfnapproxexpint,Yeh2008:traptriapprox}.
Note that if $\mathrm{amb}(A) \ge \mathrm{width}(A)/3$, then
we get the same result as in
the \texttt{'NearestEuclidean'} method.

% TO BE DONE...

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(T3 <- \hlfunctioncall{trapezoidalApproximation}(A, method=\hlstring{'ExpectedIntervalPreserving'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[-5.85235,14.4],
##       core=[-2.26529,3.2].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(A, T3)
\end{alltt}
\begin{verbatim}
## [1] 1.98043
\end{verbatim}
\begin{alltt}
\hlfunctioncall{expectedInterval}(A)
\end{alltt}
\begin{verbatim}
## [1] -4.058824  8.800000
\end{verbatim}
\begin{alltt}
\hlfunctioncall{expectedInterval}(T3)
\end{alltt}
\begin{verbatim}
## [1] -4.058824  8.800000
\end{verbatim}
\end{kframe}
\end{knitrout}


% \begin{center}


% \end{center}

Unfortunately, for highly skewed membership functions this method
(as well as the previous one) reveals sometimes quite unfavorable
behavior. E.g.~if $B$ is a FN such that
$\mathrm{Val}(B) < \mathrm{EV}_{1/3}(B)$
or $\mathrm{Val}(B) > \mathrm{EV}_{2/3}(B)$,
then it may happen that the core of the output
and the core of the original fuzzy number $B$ are disjoint,
cf.~\cite{GrzegorzewskiPasternak2011:trapapproxsupcore}.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(B  <- \hlfunctioncall{FuzzyNumber}(1, 2, 3, 45,
   lower=\hlfunctioncall{function}(x) \hlfunctioncall{sqrt}(x),
   upper=\hlfunctioncall{function}(x) 1-\hlfunctioncall{sqrt}(x)))
\end{alltt}
\begin{verbatim}
## Fuzzy number with:
##    support=[1,45],
##       core=[2,3].
\end{verbatim}
\begin{alltt}
(TB1 <- \hlfunctioncall{trapezoidalApproximation}(B, \hlstring{'NearestEuclidean'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[1.37333,33.2133],
##       core=[1.37333,1.37333].
\end{verbatim}
\begin{alltt}
(TB2 <- \hlfunctioncall{trapezoidalApproximation}(B, \hlstring{'ExpectedIntervalPreserving'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[1.66667,32.3333],
##       core=[1.66667,1.66667].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(B, TB1)
\end{alltt}
\begin{verbatim}
## [1] 2.098994
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(B, TB2)
\end{alltt}
\begin{verbatim}
## [1] 2.166239
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxExA_ExpInt3Fig} 

}



\end{knitrout}

\end{center}


\subsubsection{Approximation with Restrictions on Support and Core}


The \texttt{'SupportCoreRestricted'} method was proposed in \cite{GrzegorzewskiPasternak2011:trapapproxsupcore}.
It gives the $L_2$-nearest trapezoidal approximation with constraints
$\mathrm{core}(A) \subseteq \mathrm{core}(\mathcal{T}(A))$
and $\mathrm{supp}(\mathcal{T}(A)) \subseteq \mathrm{supp}(A)$,
i.e.~for which each point that surely belongs to $A$ also belongs to $\mathcal{T}(A)$,
and each point that surely does not belong to $A$ also does not belong to $\mathcal{T}(A)$.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
(T4 <- \hlfunctioncall{trapezoidalApproximation}(A, method=\hlstring{'SupportCoreRestricted'}))
\end{alltt}
\begin{verbatim}
## Trapezoidal fuzzy number with:
##    support=[-5,11.6],
##       core=[-3.11765,6].
\end{verbatim}
\begin{alltt}
\hlfunctioncall{distance}(A, T4)
\end{alltt}
\begin{verbatim}
## [1] 2.603383
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxExA_RestrSuppCore2} 

}



\end{knitrout}

\end{center}




\subsection{Approximation by Piecewise Linear Fuzzy Numbers}

TO BE DONE... Problem statement... Given a fuzzy number $A$ we seek for a piecewise linear
fuzzy number $\mathcal{P}(A)$....

Currently only fixed \texttt{knot.alpha} allowed.... TO BE DONE....

In this subsection we will use the following fuzzy number $A$
for the sake of illustration:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A <- \hlfunctioncall{FuzzyNumber}(-5, 3, 6, 20,
   left=\hlfunctioncall{function}(x) \hlfunctioncall{pbeta}(x,0.4,3),
   right=\hlfunctioncall{function}(x) 1-x^(1/4),
   lower=\hlfunctioncall{function}(alpha) \hlfunctioncall{qbeta}(alpha,0.4,3),
   upper=\hlfunctioncall{function}(alpha) (1-alpha)^4
)
\end{alltt}
\end{kframe}
\end{knitrout}



\subsubsection{Na\'{i}ve Approximation}

The \texttt{'Naive'} method generates a PLFN with the same
core and support as $A$ and with sides interpolating the membership function
of $A$ at given $\alpha$-cuts.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
P1 <- \hlfunctioncall{piecewiseLinearApproximation}(A, method=\hlstring{'Naive'},
         knot.n=1, knot.alpha=0.5)
P1[\hlstring{'allknots'}]
\end{alltt}
\begin{verbatim}
##        alpha      left  right
## supp     0.0 -5.000000 20.000
## knot_1   0.5 -4.583591  6.875
## core     1.0  3.000000  6.000
\end{verbatim}
\begin{alltt}
\hlfunctioncall{print}(\hlfunctioncall{distance}(A, P1), 8)
\end{alltt}
\begin{verbatim}
## [1] 2.4753305
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxPLFNNaive2} 

}



\end{knitrout}

\end{center}


\subsubsection{$L_2$-nearest Approximation}

\paragraph{Exact algorithm for fixed \texttt{knot.alpha}.}

TO BE DONE...

For \texttt{knot.n==1} the method proposed in \cite{CoroianuETAL2012:plfnapprox}
is used.

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{system.time}(P2 <- \hlfunctioncall{piecewiseLinearApproximation}(A,
   method=\hlstring{'NearestEuclidean'}, knot.n=1, knot.alpha=0.5))
\end{alltt}
\begin{verbatim}
##    user  system elapsed 
##   0.012   0.000   0.090
\end{verbatim}
\begin{alltt}
\hlfunctioncall{print}(P2[\hlstring{'allknots'}], 6)
\end{alltt}
\begin{verbatim}
##        alpha     left  right
## supp     0.0 -4.95920 17.305
## knot_1   0.5 -4.95920  5.965
## core     1.0 -1.35769  5.965
\end{verbatim}
\begin{alltt}
\hlfunctioncall{print}(\hlfunctioncall{distance}(A, P2), 12)
\end{alltt}
\begin{verbatim}
## [1] 0.837361269482
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxPLFNNearest2} 

}



\end{knitrout}

\end{center}



\bigskip
Beware of numerical error in integration e.g.~due to discontinuity
in $\alpha$-cuts........
..... TO BE DONE....

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A1 <- \hlfunctioncall{FuzzyNumber}(0,1,1,1,
         lower=\hlfunctioncall{function}(a) \hlfunctioncall{floor}(3*a)/3,
         upper=\hlfunctioncall{function}(a) 1-a
) \hlcomment{# no info on discontinuities}

A2 <- \hlfunctioncall{DiscontinuousFuzzyNumber}(0,1,1,1,
         lower=\hlfunctioncall{function}(a) \hlfunctioncall{floor}(3*a)/3,
         upper=\hlfunctioncall{function}(a) 1-a,
         discontinuities.lower=\hlfunctioncall{c}(0, 1/3, 2/3, 1),
         discontinuities.upper=\hlfunctioncall{numeric}(0)
) \hlcomment{# discontinuities info included}

a <- \hlfunctioncall{seq}(1e-9, 1-1e-9, length.out=100) \hlcomment{# many alphas \hlfunctioncall{from} (0,1)}
d1 <- \hlfunctioncall{numeric}(\hlfunctioncall{length}(a)) \hlcomment{# distances #\hlfunctioncall{1} (to be calculated)}
d2 <- \hlfunctioncall{numeric}(\hlfunctioncall{length}(a)) \hlcomment{# distances #\hlfunctioncall{2} (to be calculated)}
\hlfunctioncall{for} (i in 1:\hlfunctioncall{length}(a))
\{
   P1 <- \hlfunctioncall{piecewiseLinearApproximation}(A1, method=\hlstring{'NearestEuclidean'},
            knot.n=1, knot.alpha=a[i])
   P2 <- \hlfunctioncall{piecewiseLinearApproximation}(A2, method=\hlstring{'NearestEuclidean'},
            knot.n=1, knot.alpha=a[i])

   d1[i] <- \hlfunctioncall{distance}(A1, P1)
   d2[i] <- \hlfunctioncall{distance}(A2, P2)
\}
\end{alltt}
\end{kframe}
\end{knitrout}


We note that in the first case the distance for $\alpha=0$ (trapezoidal
approximation) is
smaller than e.g.~for $\alpha\simeq 0.05$, which, theoretically,
is not possible. Moreover, the distance is not continuous
at some $\alpha$ (but it is in theory).
% .. TO DO.....

\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/PLFNApproxNeares_error2} 

}



\end{knitrout}

\end{center}




\paragraph{Finding best \texttt{knot.alpha} numerically.}

Consider the following fuzzy number $A_1$:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
A1 <- \hlfunctioncall{FuzzyNumber}(0,0,0,1,
   lower=\hlfunctioncall{function}(a) a,
   upper=\hlfunctioncall{function}(a) (1-a)^2)
\end{alltt}
\end{kframe}
\end{knitrout}


Let us depict the $L_2$ distance $D_{A_1}(\alpha)$..........

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
a <- \hlfunctioncall{seq}(1e-9, 1-1e-9, length.out=100) \hlcomment{# many alphas \hlfunctioncall{from} (0,1)}
d <- \hlfunctioncall{numeric}(\hlfunctioncall{length}(a)) \hlcomment{# \hlfunctioncall{distances} (to be calculated)}
\hlfunctioncall{for} (i in 1:\hlfunctioncall{length}(a))
\{
   P1 <- \hlfunctioncall{piecewiseLinearApproximation}(A1, method=\hlstring{'NearestEuclidean'},
            knot.n=1, knot.alpha=a[i])
   d[i] <- \hlfunctioncall{distance}(A1, P1)
\}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: max(abs(d[K]))==7.14806e-08}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: max(abs(d[K]))==1.19959e-07}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: max(abs(d[K]))==3.57378e-07}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: max(abs(d[K]))==1.19209e-07}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: max(abs(d[K]))==2.38169e-07}}\begin{alltt}
\hlfunctioncall{plot}(a, d, type=\hlstring{'l'}, xlab=\hlfunctioncall{expression}(alpha), ylab=\hlfunctioncall{expression}(D[A](alpha)))
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/BestKnotAlphaPLFN3} 

}



\end{knitrout}

\end{center}

We may find best \texttt{knot.alpha} using numerical optimization.
We only know that the distance function is continuous.
% TO DO.....


\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{for} (i in 1:5) \hlcomment{# 5 iterations}
\{
   a0 <- \hlfunctioncall{runif}(1,0,1) \hlcomment{# random starting point}
   \hlfunctioncall{optim}(a0,
      \hlfunctioncall{function}(a)
      \{
         P1 <- \hlfunctioncall{piecewiseLinearApproximation}(A1, method=\hlstring{'NearestEuclidean'},
                                             knot.n=1, knot.alpha=a)

         \hlfunctioncall{distance}(A1, P1)
      \}, method=\hlstring{'L-BFGS-B'}, lower=1e-9, upper=1-1e-9) -> res
   \hlfunctioncall{cat}(\hlfunctioncall{sprintf}(\hlstring{'%.9f %6g %.9f %.9f\textbackslash{}n'}, a0, res$counts[1], res$par, res$value))
\}
\end{alltt}
\begin{verbatim}
## 0.083435631     33 0.545856237 0.022293594
## 0.899270690      8 0.546166579 0.022294008
## 0.525304287     62 0.545856216 0.022293594
## 0.465534228     76 0.545856366 0.022293594
## 0.903839787     51 0.545856369 0.022293594
\end{verbatim}
\end{kframe}
\end{knitrout}






\paragraph{Approximate algorithm for fixed \texttt{knot.alpha}.}

This method uses a constrained version of the Nelder-Mead algorithm.
The procedure minimizes the target function numerically
by calling the \texttt{optim()} function.
There is thus no guarantee that it will find to the global minimum
(it may fall into a neighborhood of a local minimum
or even fail to converge).
However, this approach may be used for any number of knots.

TO BE DONE... WORK  ON AN EXACT ALGORITHM IS IN PROGRESS.....

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{system.time}(P3 <- \hlfunctioncall{piecewiseLinearApproximation}(A,
   method=\hlstring{'ApproximateNearestEuclidean'}, knot.n=1, knot.alpha=0.5))
\end{alltt}
\begin{verbatim}
##    user  system elapsed 
##   1.299   0.003   1.330
\end{verbatim}
\begin{alltt}
\hlfunctioncall{print}(P3[\hlstring{'allknots'}], 6)
\end{alltt}
\begin{verbatim}
##        alpha     left    right
## supp     0.0 -4.95921 17.30510
## knot_1   0.5 -4.95921  5.96493
## core     1.0 -1.35761  5.96493
\end{verbatim}
\begin{alltt}
\hlfunctioncall{print}(\hlfunctioncall{distance}(A, P3), digits=12)
\end{alltt}
\begin{verbatim}
## [1] 0.837361274848
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Compare with exact solution......
Please note that a call to this method may be time-consuming.

Another example:

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{system.time}(P4 <- \hlfunctioncall{piecewiseLinearApproximation}(A,
   method=\hlstring{'ApproximateNearestEuclidean'}, knot.n=4,
   knot.alpha=\hlfunctioncall{c}(0.2, 0.3, 0.7, 0.9), verbose=TRUE))
\end{alltt}
\begin{verbatim}
## Pass 1a,1b,DONE.
##    user  system elapsed 
##  35.655   0.017  36.370
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{center}
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=4.5in]{figures-knitr/ApproxMethodPLFN3} 

}


\begin{kframe}\begin{verbatim}
## [1] 0.283699551483
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{center}

If the method fails to converge, you may try to call it
e.g.~with the \texttt{optim.control=list(maxit=\allowbreak{}5000)} parameter
to allow for greater number of iterations.









\section{NEWS/CHANGELOG}

\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
FuzzyNumbers Package NEWS

***************************************************************************

0.3 /under development/

* Added a call to  setGeneric("plot", function(x, y, ...) ...
  to avoid a warning on install

* New methods: as.character(); also used by show().
  This function also allows to generate LaTeX code defining the FN
  (toLaTeX arg thanks to Jan Caha).

* New binary arithmetic operators, especially
   for PiecewiseLinearFuzzyNumbers: +, -, *, /

* piecewiseLinearApproximation() and as.PiecewiseLinearFuzzyNumber()
  argument `knot.alpha` now defaults to equally distributed knots
  (via given `knot.n`)

* PiecewiseLinearFuzzyNumber() now accepts missing `a1`, `a2`, `a3`, `a4`,
  and `knot.left`, `knot.right` of length `knot.n`+2. Moreover, if `knot.n`
  is not given, then it is guessed from length(knot.left).
  If `knot.alpha` is missing, then the knots will be equally distributed
  on the interval [0,1].

* New function: fapply() - applies a function on a PLFN
  using the extension principle

* as.PiecewiseLinearFuzzyNumber() is now an S4 method,
  and can be called on objects of type numeric, as well as on
  various FNs

* ...

* The FuzzyNumbers Tutorial has been properly included
  as the package's vignette

* Man pages update & cleanup

***************************************************************************

0.2 /2012-12-27/

* approx.invert(): a new function to find the numerical
  inverse of a given side/alpha-cut generating function
  (by default via Hermite monotonic spline interpolation)

* convert.side(), convert.alpha():
  new functions to convert sides and alpha cuts
  to side generating funs and alpha cut generators

* FuzzyNumber class validity check for lower, upper, left, right:
   * checks whether each function is properly vectorized
      and gives numeric results
   * does not check for the number of formal arguments,
      but just uses the first from the list

* suggests `testthat`

* each object has been documented

* first CRAN release

***************************************************************************

0.1 /2012-07-01/

* initial release
\end{verbatim}
\end{kframe}
\end{knitrout}



\paragraph{Acknowledgments.}
This document has been generated with \LaTeX, \package{knitr} and
the \package{tikzDevice} package for \R.
Their authors' wonderful work is fully appreciated.
Many thanks to Jan Caha for contributions to the package's source code,
and also to Przemys\l{}aw Grzegorzewski, Lucian Coroianu
and Pablo Villacorta Iglesias for stimulating discussion.



The contribution of Marek Gagolewski was partially supported
by the European Union from resources of the European Social Fund, Project PO KL 
``Information technologies: Research and their interdisciplinary
applications'', agreement UDA-POKL.04.01.01-00-051/10-00 (March-June 2013),
and by FNP START Scholarship from the Foundation for Polish Science (2013).




\bibliographystyle{acm}
\bibliography{bibliography}

\end{document}
