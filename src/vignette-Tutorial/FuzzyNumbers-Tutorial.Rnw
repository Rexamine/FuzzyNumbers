\documentclass[11pt]{article}
%\VignetteIndexEntry{A Guide to the FuzzyNumbers Package}
%\VignetteEngine{knitr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage[dvips,a4paper,left=2.5cm,right=2.5cm,foot=1.0cm,
   headheight=1.0cm,top=2.0cm,margin=2.5cm]{geometry}
\linespread{1.1}

\usepackage{fancyhdr}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\selectlanguage{english}
\usepackage{xspace}
\usepackage{lmodern}

\usepackage{amsmath,amssymb,amsfonts}
\RequirePackage{graphicx,verbatim,longtable}
\usepackage{mdwlist}
\usepackage{multirow,multicol}
\usepackage[nottoc]{tocbibind}
\usepackage{rotating}

\newcommand{\email}[1]{\href{mailto:#1}{#1}}
\renewcommand{\emph}[1]{\textsl{#1}}
\newcommand{\indicator}{\text{\bf 1}}
\renewcommand{\Pr}{\mathrm{P}}
\renewcommand{\ln}{\mathrm{ln}\,}

\newcommand{\package}[1]{\textsf{#1}\xspace}
\newcommand{\program}[1]{\textsf{#1}\xspace}
\newcommand{\os}[1]{\textsf{#1}\xspace}
\newcommand{\lang}[1]{\textsf{#1}\xspace}
\newcommand{\Cpp}{\lang{C++}}
\newcommand{\R}{\lang{R}}

\newcommand{\func}[1]{\texttt{\hlfunctioncall{#1}}}
\newcommand{\argument}[1]{\texttt{\hlargument{#1}}}
\newcommand{\str}[1]{\texttt{\hlstring{#1}}}
\newcommand{\key}[1]{{$\langle$\texttt{#1}$\rangle$}\xspace} % skrot klawiszowy

\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}


\usepackage{xcolor}
\definecolor{blue2}{rgb}{0,0.2,0.7}
\definecolor{red2}{rgb}{0.4,0.1,0.1}
\usepackage{colortbl}
\definecolor{navy}{rgb}{0,0.0,0.4}
\definecolor{navy2}{rgb}{0.4,0.1,0.3}
\definecolor{red2}{rgb}{0.6,0.1,0.2}
\definecolor{green2}{rgb}{0.1,0.4,0.2}

\usepackage{hyperref}

\usepackage{caption}
\captionsetup{font=small,labelfont=bf,labelsep=period,justification=centering}
\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Tab.}}


\setlength{\topsep}{1pt} % wpływa m.in. na odstęp dla verbatim
\tolerance=500
\predisplaypenalty=0
\clubpenalty=1000
\widowpenalty=1000



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}



\begin{center}
{\LARGE\sf A Guide to the \package{FuzzyNumbers} {0.03-devel} Package for \R}

\bigskip
{\large Marek Gagolewski${}^{1,2}$}

${}^{1}$ Systems Research Institute, Polish Academy of Sciences

ul. Newelska 6, 01-447 Warsaw, Poland

${}^{2}$ Rexamine, Email: \texttt{gagolews@rexamine.com}

\href{http://www.rexamine.com/resources/fuzzynumbers/}%
{www.rexamine.com/resources/fuzzynumbers/}

\bigskip
\today



\medskip
\textit{The package, as well as this tutorial, is still in its early
days -- any suggestions are welcome!}
\end{center}





\bigskip\hrule\bigskip
\tableofcontents

<<echo=FALSE,results='hide',warning=FALSE,message=FALSE,cache=FALSE>>=
options(digits=7)
options(width=73)
require("knitr")
require("tikzDevice")

options(tikzDefaultEngine = "pdftex")

options(tikzLatexPackages = c( # dolaczanie uzywanych pakietow TeX-a
   "\\usepackage{amsmath,amssymb,amsfonts}", # pakiety AMS
   "\\usepackage{tikz}",
#   "\\usepackage[MeX,T1,plmath]{polski}", # obsluga m.in. polskich ogonkow
   "\\usepackage[utf8]{inputenc}",
   "\\usepackage[T1]{fontenc}",
   "\\usetikzlibrary{calc}",
   "\\usepackage[english]{babel}",
   "\\selectlanguage{english}",
   "\\usepackage{standalone}"
))

options(tikzMetricsDictionary="/home/gagolews/R/tikzMetrics")

options(tikzDocumentDeclaration = "\\documentclass[11pt]{standalone}\n")

options(tikzMetricPackages = c(
   "\\usepackage[utf8]{inputenc}",
   "\\usepackage[T1]{fontenc}",
   "\\usepackage{amsmath,amssymb,amsfonts}",
   "\\usetikzlibrary{calc}",
   "\\usepackage[english]{babel}",
   "\\selectlanguage{english}"
))



opts_knit$set(progress = TRUE, verbose = TRUE)

opts_chunk$set(
   keep.source=TRUE,
   out.width='4.5in',
   fig.width=6,
   fig.height=6/sqrt(2),
   fig.path='figures-knitr/',
   cache.path='cache-knitr/',
   cache=TRUE,
   tidy=FALSE,
#    dev='cairo_pdf',
#    dev.args=list(pointsize=11),
   dev='tikz',
   external=TRUE,
   fig.align='center',
   size='small'
)

# knit_theme$set(knit_theme$get("solarized-light"))
@

% \definecolor{fgcolor}{gray}{0}
% \renewcommand{\hlnumber}[1]{\textcolor[gray]{0.2}{#1}}%
% \renewcommand{\hlfunctioncall}[1]{\textbf{#1}}%
% \renewcommand{\hlstring}[1]{\textcolor[gray]{0.2}{\textit{#1}}}%
% \renewcommand{\hlkeyword}[1]{\textbf{#1}}%
% \renewcommand{\hlargument}[1]{\textcolor[rgb]{0.2,0.2,0.2}{\textsl{#1}}}%
% \renewcommand{\hlcomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlroxygencomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hlassignement}[1]{\textcolor[gray]{0}{\textbf{#1}}}%
% \renewcommand{\hlpackage}[1]{\textcolor[rgb]{0.59,0.71,0.15}{#1}}%
% \renewcommand{\hlslot}[1]{\textit{#1}}%
% \renewcommand{\hlsymbol}[1]{\textcolor[cmyk]{0,0,0,1}{#1}}%
% \renewcommand{\hlprompt}[1]{\textcolor[cmyk]{0,0,0,0.5}{#1}}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Getting started}

Fuzzy set theory lets us effectively and quite intuitively represent
imprecise or vague information. Fuzzy numbers (FNs), introduced
by Dubois and Prade in \cite{DuboisPrade1978}, form a particular
subclass of fuzzy sets of the real line. They play a significant role
in many important theoretical and practical considerations
(cf.~\cite{KlirYuan1995:fuzzybook})
since we often describe our knowledge about objects
through numbers, e.g. ``I'm about 180 cm tall''
or ``The rocket was launched between 2 and 3 p.m.''.

\R is a free, open sourced software environment
for statistical computing and graphics, which
includes an implementation
of a very powerful and quite popular high-level language called \lang{S}.
It runs on all major operating systems, i.e.~\os{Windows},
\os{Linux}, and \os{MacOS X}.
To install \R and/or find some information on the \lang{S} language
please visit \R Project's Homepage at \href{http://www.R-project.org}{www.R-project.org}.
Perhaps you may also wish to install  \program{RStudio},
a convenient development environment for \R.
It is available at \href{http://rstudio.org/}{www.rsudio.org}.


\bigskip
\package{FuzzyNumbers} is an Open Source (licensed under GNU LGPL 3)
package for \R$\ge$ 2.12 to which anyone can contribute.
It has been created in order to deal with fuzzy numbers
conveniently and effectively. To install its latest ``official'' release 
available on \textit{CRAN} we type:

<<eval=FALSE>>=
install.packages("FuzzyNumbers")
@

\noindent
Alternatively, we may fetch its current development snapshot
(without man pages, but see our homepage\footnote{%
\href{http://www.ibspan.waw.pl/~gagolews/?page=resources&subpage=FuzzyNumbers&manpage=00Index}%
{www.ibspan.waw.pl/$\sim$gagolews/?page=resources\&subpage=FuzzyNumbers\&manpage=00Index}.}) 
from \textit{GitHub}.


\bigskip
Each session with \package{FuzzyNumbers} should be preceded by
a call to:

<<libraryFuzzyNumbers,results='hide',warning=FALSE,message=FALSE>>=
library("FuzzyNumbers") # Load the package
@

\bigskip
To view the main page of the manual we type:

<<helpFuzzyNumbers,eval=FALSE>>=
library(help="FuzzyNumbers")
@

\noindent
For more information please visit the package's homepage \cite{FuzzyNumbersHome}.
In case of any problems, comments, or suggestions feel free to contact the author.
Good luck!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{How to create instances of fuzzy numbers}


\subsection{Arbitrary  fuzzy numbers}

A fuzzy number $A$ may be defined by specifying
its core, support, and either its left/right side functions
or lower/upper $\alpha$-cut bounds. Please note that many algorithms that
deal with FNs assume we provide at least the latter, i.e.~$\alpha$-cuts.

\subsubsection{Definition by side functions}

A fuzzy number $A$ specified by side functions\footnote{Side functions
  are sometimes called branches or shape functions in the literature.}
has a membership function
of the form:
\begin{equation}
\mu_A(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\mathtt{left}\left( \frac{x-\mathtt{a1}}{\mathtt{a2-a1}} \right)  & \text{if } \mathtt{a1} \le x < \mathtt{a2}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\mathtt{right}\left( \frac{x-\mathtt{a3}}{\mathtt{a4-a3}} \right)  & \text{if } \mathtt{a3} < x \le \mathtt{a4}, \\
0 & \text{if } \mathtt{a4}<x, \\
\end{array}\right.
\end{equation}
where $\mathtt{a1},\mathtt{a2},\mathtt{a3},\mathtt{a4}\in\mathbb{R}$,
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
$\mathtt{left}: [0,1]\to[0,1]$ is a nondecreasing function
(called \textit{left side generator of $A$}),
and $\mathtt{right}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{right side generator of $A$}).
In our package, it is assumed that these functions fulfill the conditions
$\mathtt{left}(0)\ge 0$, $\mathtt{left}(1)\le 1$,
$\mathtt{right}(0)\le 1$, and $\mathtt{right}(1)\ge 0$.


Please note that by using side generating functions defined on $[0,1]$
% (instead of the most common approach, i.e.~ordinary side functions
% such that $l_A(x)=\frac{x-\mathtt{a1}}{\mathtt{a2-a1}}$
% and $r_A(x)=\frac{x-\mathtt{a3}}{\mathtt{a4-a3}}$)
we really make (in author's humble opinion) the process of generating
examples for our publications much easier.
A similar concept was used e.g.~in \cite{StefaniniSorini2009:eusflat}
(LR-fuzzy numbers).

\bigskip
An example: a fuzzy number $A_1$ with linear sides
(a trapezoidal fuzzy number, see also Sec.~\ref{Sec:TFNdef}).

<<A1ex>>=
A1 <- FuzzyNumber(1, 2, 4, 7,
    left=function(x) x,
   right=function(x) 1-x
)
@

\noindent
This object is an instance of the following \R class:

<<A1ex2,dependson='A1ex'>>=
class(A1)
@

\noindent
We may print some basic information on $A_1$ by calling \texttt{\func{print}(A1)} or
simply by typing:

<<A1ex3,dependson='A1ex'>>=
A1
@

\noindent
To depict $A_1$ we call:

<<A1ex4,dependson='A1ex',fig.keep='none'>>=
plot(A1)
@

\begin{center}
<<A1ex5,dependson='A1ex',echo=FALSE>>=
plot(A1, xlab="$x$", ylab="$\\alpha$", main="")
@
\end{center}

\noindent
If we would like to generate figures for our publications,
then we will be interested in storing them as PDF files.
This may be done by calling:

<<A1ex6,dependson='A1ex',eval=FALSE>>=
pdf("figure1.pdf", width=8, height=5) # create file
plot(A1)
dev.off() # close graphical device and save the file
@

\noindent
Postscript (PS) files are generated by substituting the call
to \func{pdf()} for the call to the \func{postcript()} function.





\paragraph{Remark.}
Assume we are given two fancy side functions $f: [a_1,a_2]=[-4,-2]\to[0,1]$,
and $g: [a_3,a_4]=[-1,10]\to[1,0]$,
for example:

<<ExFconvert>>=
f <- splinefun(c(-4,-3.5,-3,-2.2,-2), c(0,0.4,0.7,0.9,1), method="monoH.FC")
g <- splinefun(c(-1,0,10), c(1,0.5,0), method="monoH.FC")
@

Let us convert them to side \textit{generating} functions, which shall be
defined on the interval $[0,1]$.
This may easily be done with the \func{convert.side()}
function. It returns a new function that calls
the original one with linearly transformed input.

<<ExFconvert2,dependson='ExFconvert'>>=
convert.side(f, -4, -2)(c(0,1))
convert.side(g, -1, 10)(c(0,1))
convert.side(g, 10, -1)(c(0,1)) # interesting!
@

\noindent
These functions may be used to define a fuzzy number,
now with arbitrary support and core.

<<ExFconvert3,dependson='ExFconvert2',fig.keep='none'>>=
B <- FuzzyNumber(10,20,20,30,
    left=convert.side(f, -4, -2),
   right=convert.side(g, -1, 10)
)
plot(B, xlab="$x$", ylab="$\\alpha$")
@

\begin{center}
<<ExFconvert4,dependson='ExFconvert3',echo=FALSE>>=
<<ExFconvert3>>
@
\end{center}



\subsubsection{Definition by $\alpha$-cut bounds}

Alternatively, a fuzzy number $A$ may be defined by specifying 
its $\alpha$-cuts. We have (for $\alpha\in(0,1)$ and 
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$):
\begin{eqnarray}
A_\alpha & := & [A_L(\alpha), A_U(\alpha)]\\
 & = & \big[
   \mathtt{a1}+(\mathtt{a2}-\mathtt{a1})\cdot\mathtt{lower}(\alpha),
   \mathtt{a3}+(\mathtt{a4}-\mathtt{a3})\cdot\mathtt{upper}(\alpha)
\big],
\end{eqnarray}
where $\mathtt{lower}: [0,1]\to[0,1]$ is a nondecreasing function
(called \textit{lower $\alpha$-cut bound generator of $A$}),
and $\mathtt{upper}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{upper bound generator}).
In our package, we assumed that
$\mathtt{lower}(0)=0$, $\mathtt{lower}(1)=1$,
$\mathtt{upper}(0)=1$, and $\mathtt{upper}(1)=0$.

It is easily seen that for $\alpha\in(0,1)$ we have the following
relationship between generating functions:
\begin{eqnarray}
\mathtt{lower}(\alpha) & = & \inf\{x: \mathtt{left}(x)\ge\alpha\}, \\
\mathtt{upper}(\alpha) & = & \sup\{x: \mathtt{right}(x)\ge\alpha\}.
\end{eqnarray}
Moreover, if side generating functions are continuous and strictly
monotonic, then $\alpha$-cut bound generators are their inverses.

\bigskip\noindent
An example:

<<alphacutEx,fig.keep='none'>>=
A1 <- FuzzyNumber(1, 2, 4, 7,
    left=function(x) x,
   right=function(x) 1-x
)
A2 <- FuzzyNumber(1, 3, 4, 7,
   lower=function(alpha) pbeta(alpha, 5, 9), # CDF of a beta distr.
   upper=function(alpha) pexp(1/alpha-1) # transformed CDF of an exp. distr.
)
plot(A1, col="blue")
plot(A2, col="red", lty=2, add=TRUE)
legend("topright", c(expression(mu[A1]), expression(mu[A2])),
   col=c("blue", "red"), lty=c(1,2));
@

\begin{center}
<<alphacutEx2,dependson='alphacutEx',echo=FALSE>>=
plot(A1, col="blue", xlab="$x$", ylab="$\\alpha$")
plot(A2, col="red", lty=2, add=TRUE)
legend("topright", c("$\\mu_{A1}$", "$\\mu_{A2}$"),
   col=c("blue", "red"), lty=c(1,2));
@
\end{center}




\paragraph{Remark.}
The \func{convert.alpha()} function
works similarly to \func{convert.side()}.
This tool, however, scales the output values
of a given function, thus it may be used to create
an alpha-cut generator conveniently.

\subsubsection{Definition with generating functions omitted: shadowed sets}

Please note that in the above examples we passed to the
constructor of each \texttt{FuzzyNumber} class instance
either side generating functions or $\alpha$-cut generators.
Let us study what happens, if we omit both of them.

<<A3def>>=
A3 <- FuzzyNumber(1, 2, 4, 5)
A3
@

\noindent
The object seems to be defined correctly: \R does not make any
complaints. However\dots

<<A3deffig,dependson='A3def',fig.keep='none'>>=
plot(A3)
@

\begin{center}
<<A3deffig2,dependson='A3def',echo=FALSE>>=
plot(A3, xlab="$x$", ylab="$\\alpha$", shadowcol="gray")
@
\end{center}

\noindent
It turns out that we have obtained a \textit{shadowed set}!
Indeed, this behavior is quite reasonable: we have provided no information
on the ``partial knowledge'' part of our fuzzy number.
In fact, the object has been initialized
with generating functions always returning \texttt{NA}
(\textit{Not-Available} or \textit{any} value).
Does it mean that when we define a FN solely by side generators, we
cannot compute its $\alpha$-cuts? Indeed!

<<alphacutEx3,dependson='alphacutEx'>>=
alphacut(A2, 0.5) # A2 has alpha-cut generators defined
alphacut(A1, 0.5) # A1 hasn't got them
@

\noindent
Another example: evaluation of the membership function.

<<alphacutEx4,dependson='alphacutEx'>>=
evaluate(A1, 6.5) # A1 has side generators defined
evaluate(A2, 6.5) # A2 hasn't got them
@

\subsection{Using numeric approximations
of $\alpha$-cut or side generators}

The reason for setting  by default
\texttt{NA}s\footnote{To be precise, it's \texttt{NA\_real\_}.}
as return values of generators
(when omitted) is simple. Finding a function inverse numerically
requires lengthy computations and is always done locally
(for a given point, not for ``whole'' the function at once).
\R is not a symbolic mathematical solver.
If we had defined such procedures (it is really easy to do
by using the \texttt{uniroot()} function), then an inexperienced user
would have used it in his/her algorithms and wondered why everything
runs so slow. To get more insight, let us look at the internals of \texttt{A2}:

<<alphacutEx5,dependson='alphacutEx'>>=
A2["lower"]
A2["upper"]
A2["left"]
A2["right"]
@

\noindent
Note that all generators are properly vectorized (for
input vectors of length $n$ they always give output of the
same length).
Thus, general rules are as follows.
If you want $\alpha$-cuts (e.g.~for finding
trapezoidal approximations of FNs), specify them.
If you would like to access side functions (by the way,
the \texttt{plot()} function
automatically detects what kind of knowledge we have),
assure they are provided.


However, we we provide some convenient short-cut methods
to \textit{interpolate} generating functions of one type
to get some crude numeric approximations of their inverses.
These are simple wrappers to \R's \func{approxfun()}
(piecewise linear interpolation,
the \str{"{}linear"{}} \argument{method})
and \func{splinefun()} (monotonic
splines: \argument{method}s \str{"{}hyman{}"}
and \str{"{}monoH.FC"{}}; the latter is
default and recommended).
They are available as the \func{approx.invert()}
function\footnote{The
\argument{n} argument, which sets the number of interpolation points,
controls the trade-off between accuracy and computation speed.
Well, world's not ideal, remember that ``any'' is better than ``nothing''
sometimes.}, and may
of course be used on results returned by
\func{convert.alpha()}
and \func{convert.side()}.


<<approxfuns>>=
l <- function(x) pbeta(x, 1, 2)
r <- function(x) 1-pbeta(x, 1, 0.1)
A4 <- FuzzyNumber(-2, 0, 0, 2,
   left  = l,
   right = r,
   lower = approx.invert(l),
   upper = approx.invert(r)
)

x <- seq(0,1,length.out=1e5)
max(abs(qbeta(x, 1, 2) - A4["lower"](x)))     # sup-error
max(abs(qbeta(1-x, 1, 0.1) - A4["upper"](x))) # sup-error
@

\subsection{Fuzzy numbers with discontinuities}\label{Sec:discontdef}

... TO BE DONE ....

<<fig.keep='none'>>=
A1 <- FuzzyNumber(0,1,1,1,
         lower=function(a) floor(3*a)/3,
         upper=function(a) 1-a
) # no info on discontinuities

A2 <- DiscontinuousFuzzyNumber(0,1,1,1,
         lower=function(a) floor(3*a)/3,
         upper=function(a) 1-a,
         discontinuities.lower=c(0, 1/3, 2/3, 1),
         discontinuities.upper=numeric(0)
) # discontinuities info included
@

% plots.....

% integration errors without this info.... (!)

... TO BE DONE ....


\subsection{Trapezoidal  fuzzy numbers}\label{Sec:TFNdef}

A trapezoidal fuzzy number (TFN) is a FN which has linear
side generators and linear $\alpha$-cut bound generators.
To create a trapezoidal fuzzy number $T_1$
with, for example, $\mathrm{core}(T_1)=[2,4]$
and $\mathrm{supp}(T_1)=[1,7]$ we call:

<<>>=
T1 <- TrapezoidalFuzzyNumber(1,2,4,7)
@

\noindent
This object is an instance of the following \R class:

<<>>=
class(T1)
@

\noindent
To depict $T_1$ we call:

<<fig.keep='none'>>=
plot(T1)
@

\begin{center}
<<echo=FALSE>>=
plot(T1, xlab="$x$", ylab="$\\alpha$")
@
\end{center}


\bigskip
$T_1$ is (roughly) equivalent to the trapezoidal fuzzy number $A_1$
defined in the previous subsection.
The \texttt{Trapezo\-idalFuzzyNumber}
class inherits all the goodies from the \texttt{FuzzyNumber} class,
but is more specific (guarantees faster computations,
contains more detailed information, etc.).
Of course, in this case the generating functions are known \textit{a priori}
($A_1$ had no $\alpha$-cut generators)
so there is no need to provide them manually
(what is more, this has been disallowed for safety reasons).
Thus, is we wanted to define a trapezoidal FN next time, we would rather
not do it like with $A_1$ but as with $T_1$.

<<>>=
T1["lower"]
T1["upper"]
T1["left"]
T1["right"]
@




\bigskip\noindent
Trapezoidal fuzzy numbers are among the simplest FNs.
Despite their simplicity, however, they include triangular FNs,
``crisp'' real intervals, and ``crisp'' reals.
Please note that currently no separate classes for these particular TFNs types
are implemented in the package.

<<>>=
TrapezoidalFuzzyNumber(1,2,2,3)  # triangular FN
TrapezoidalFuzzyNumber(2,2,3,3)  # `crisp' interval
TrapezoidalFuzzyNumber(5,5,5,5)  # `crisp' real
@




\subsection{Piecewise linear  fuzzy numbers}

Trapezoidal fuzzy numbers are generalized by piecewise linear FNs (PLFNs),
i.e.~fuzzy numbers which side generating functions and $\alpha$-cut
generators are piecewise linear functions.
Each PLFN is given by:
\begin{itemize*}
\item four coefficients $\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$
defining its support and core,
\item the number of ``knots'', \texttt{knot.n}$\ge 0$,
\item a vector of $\alpha$-cut coordinates, \texttt{knot.alpha}, consisting of \texttt{knot.n} elements $\in[0,1]$,
\item a nondecreasingly sorted vector \texttt{knot.left} consisting of \texttt{knot.n} elements $\in[\mathtt{a1},\mathtt{a2}]$,
defining interpolation points for the left side function, and
\item a nondecreasingly sorted vector \texttt{knot.right} consisting of \texttt{knot.n} elements $\in[\mathtt{a2},\mathtt{a3}]$,
defining interpolation points for the right side function.
\end{itemize*}

If \texttt{knot.n}$\ge 1$, then the membership function of
a piecewise linear fuzzy number $P$ is defined as:
\begin{equation}
\mu_P(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\alpha_i+(\alpha_{i+1}-\alpha_i) \left(\frac{x-l_i}{l_{i+1}-l_i}\right)  & \text{if }\ \, l_i \le x < l_{i+1}\\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\alpha_{n-i+2}+(\alpha_{n-i+3}-\alpha_{n-i+2}) \left(1-\frac{x-r_i}{r_{i+1}-r_i}\right)  & \text{if}\ \, r_i < x \le r_{i+1} \\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
0 & \text{if } \mathtt{a4}<x,
\end{array}\right.
\end{equation}
and its $\alpha$-cuts for $\alpha\in[\alpha_i, \alpha_{i+1}]$
(for some $i\in\{1,\dots,n+1\}$) are given by:
\begin{eqnarray}
P_L(\alpha) & = & l_i+(l_{i+1}-l_i)\left(\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right), \\
P_U,(\alpha) & = & r_{n-i+2}+(r_{n-i+3}-r_{n-i+2})\left(1-\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right),
\end{eqnarray}
where $n=\mathtt{knot.n}$, $(l_1,\dots,l_{n+2}) = (\mathtt{a1},\mathtt{knot.left},\mathtt{a2})$,
$(r_1,\dots,r_{n+2}) = (\mathtt{a3},\mathtt{knot.right},\mathtt{a4})$,
and $(\alpha_1,\dots,\alpha_{n+2})=(0,\mathtt{knot.alpha},1)$.

\bigskip
PLFNs in our package are represented by the \texttt{PiecewiseLinearFuzzyNumber} class.

<< fig.keep='none'>>=
P1 <- PiecewiseLinearFuzzyNumber(0, 1, 2, 3,
   knot.n=1, knot.alpha=0.25, knot.left=0.5, knot.right=2.25)
class(P1)
P1
P2 <- PiecewiseLinearFuzzyNumber(0, 1, 2, 3,
   knot.n=2, knot.alpha=c(0.25,0.6),
   knot.left=c(0.5,0.8), knot.right=c(2.25, 2.5))
P2
plot(P1, type='b')
plot(P2, type='b', col=2, lty=2, pch=2, add=TRUE)
@

\begin{center}
<<echo=FALSE>>=
plot(P1, type='b', xlab="$x$", ylab="$\\alpha$")
plot(P2, type='b', col=2, lty=2, pch=2, add=TRUE)
@
\end{center}

The following operators return matrices with all knots of a PLFN.
Each of them have three columns, in order: $\alpha$-cuts,
left side coordinates, and right side coordinates.

<<>>=
P2["knots"]
P2["allknots"] # including a1,a2,a3,a4
@

\bigskip
If \texttt{knot.n} is equal to 0 or all left and right knots lie on common lines,
then a PLFN reduces to a TFN.
Please note that, however, the \texttt{TrapezoidalFuzzyNumber} class
does not inherit from \texttt{PiecewiseLinearFuzzyNumber}
for efficiency reasons.
If, however, we wanted to convert an object
of the first mentioned class to the other,
we would do that by calling:

<<fig.keep='none'>>=
alpha <- c(0.2, 0.3, 0.5, 0.6, 0.9);
P3 <- as.PiecewiseLinearFuzzyNumber(T1,
         knot.n=5, knot.alpha=alpha);
P3
plot(P3)
abline(h=alpha, col="gray", lty=2)
abline(v=P3["knot.left"], col="gray", lty=3)
abline(v=P3["knot.right"], col="gray", lty=3)
text(7, alpha, sprintf("a=%g", alpha), pos=3)
@

\begin{center}
<<echo=FALSE>>=
plot(P3, type='b', xlab="$x$", ylab="$\\alpha$")
abline(h=alpha, col="gray", lty=2)
abline(v=P3["knot.left"], col="gray", lty=3)
abline(v=P3["knot.right"], col="gray", lty=3)
text(7, alpha, sprintf("$\\alpha=%g$", alpha), pos=3)
@
\end{center}

\noindent
More generally, each PLFN or TFN may be converted
to a direct \texttt{FuzzyNumber} class instance if needed
(hope we will newer not).

<<>>=
(as.FuzzyNumber(P3))
@

On the other hand, to ``convert'' (with possible information loss)
more general FNs to TFNs or PLFNs, we may use the approximation
procedures described in Sec.~\ref{Sec:Approximation}.



\subsection{Fuzzy numbers with sides given by power functions}\label{Sec:powerdef}

Fuzzy numbers which sides are given by power functions
are defined with four coefficients $\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
and parameters $\mathtt{p.left},\mathtt{p.right}>0$ which determine
exponets for the side functions:
\begin{eqnarray}
\mathtt{left}(x)&=&x^{\mathtt{p.left}},\\
\mathtt{right}(x)&=&(1-x)^{\mathtt{p.right}}.
\end{eqnarray}
We also have:
\begin{eqnarray}
\mathtt{lower}(\alpha)&=&\sqrt[\mathtt{p.left}]{\alpha},\\
\mathtt{upper}(\alpha)&=&1-\sqrt[\mathtt{p.right}]{\alpha}.
\end{eqnarray}
These fuzzy numbers are another natural generalization of trapezoidal FNs.

An example:
<<fig.keep='none'>>=
X <- PowerFuzzyNumber(-3, -1, 1, 3, p.left=2, p.right=0.1)
class(X)
X
plot(X)
@

\begin{center}
<<echo=FALSE>>=
plot(X, type='l', xlab="$x$", ylab="$\\alpha$")
@
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Depicting  fuzzy numbers}


To depict FNs we use the \texttt{plot()} method,
which uses similar parameters as the \R-built-in
\texttt{curve()} function. If you are new to \R, you may wish
to read the manual on the most popular graphical routines by
calling \texttt{?plot}, \texttt{?plot.default}, \texttt{?curve},
\texttt{?abline}, \texttt{?par}, \texttt{?lines}, \texttt{?points},
\texttt{?legend}, \texttt{?text} (some of these functions have
already been called in this tutorial).

Let us consider the following FN:

<<depicting1a,fig.keep='none'>>=
A <- FuzzyNumber(-5, 3, 6, 20,
    left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
plot(A)
@

\begin{center}
<<depicting1b,dependson='depicting1a',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
@
\end{center}

\paragraph{Plotting issues: discretization.}
Side functions or $\alpha$-cut bounds of objects of the \texttt{FuzzyNumber}
class (not including its derivatives) when plotted are naively
approximated by piecewise linear functions with equidistant knots
at one of the axes. Therefore, if we probe them
at too few points, we may obtain very rough graphical representations.
To control the number of points at which the interpolation takes place,
we use the \texttt{n} parameter (which defaults to \texttt{101} = quite
accurate).

All three calls to the \texttt{plot()} method below depict the membership
function of the same fuzzy number, but with different accuracy.

<<depicting1c,dependson='depicting1b',fig.keep='none'>>=
plot(A, n=3, type='b')
plot(A, n=6, add=TRUE,  lty=2, col=2, type='b', pch=2)
plot(A, n=101, add=TRUE, lty=4, col=4) # default n
@

\begin{center}
<<depicting1d,dependson='depicting1c',echo=FALSE>>=
plot(A, n=3, type='b', xlab="$x$", ylab="$\\alpha$")
plot(A, n=6, add=TRUE, lty=2, col=2, type='b', pch=2)
plot(A, n=101, add=TRUE, lty=4, col=4) # default n
@
\end{center}




\paragraph{Making use of different generating functions' types.}
Please note (if you have not already) that to draw the membership
function we do not need to provide necessarily the FN with side generators:
the $\alpha$-cuts will also suffice.
The function is smart enough to detect the internal
representation of the FN and use the kind representation it has.
It both types of generators are given then side functions are used.
If we want to, for some reasons, use $\alpha$-cuts, then we may do as follows:

<<depicting1e,dependson='depicting1d',fig.keep='none'>>=
plot(A, n=3, at.alpha=numeric(0), type='b') # use alpha-cuts
plot(A, n=3, type='b', col=2, lty=2, pch=2, add=TRUE) # use sides
@

\begin{center}
<<depicting1f,dependson='depicting1e',echo=FALSE>>=
plot(A, n=3, at.alpha=numeric(0), type='b', xlab="$x$", ylab="$\\alpha$") # use alpha-cuts
plot(A, n=3, type='b', col=2, lty=2, pch=2, add=TRUE) # use side generators
@
\end{center}

\bigskip
We may also illustrate an $\alpha$-cut representation of a fuzzy number:

<<depicting1g,dependson='depicting1f',fig.keep='none'>>=
plot(A, draw.alphacuts=TRUE)
@

\begin{center}
<<depicting1h,dependson='depicting1g',echo=FALSE>>=
plot(A, draw.alphacuts=TRUE, ylab="$x$", xlab="$\\alpha$")
@
\end{center}


\paragraph{Conversion to \LaTeX.}
Another way to depict a FN is to\dots give a mathematical expression
which defines it.

<<depicting1i,dependson='depicting1h',eval=FALSE>>=
cat(as.character(A, toLaTeX=TRUE))
@

\noindent This gives the following \LaTeX{} code\dots
\begin{verbatim}
<<depicting1i2,dependson='depicting1i',results='asis',echo=FALSE>>=
cat(as.character(A, toLaTeX=TRUE))
@
\end{verbatim}

\noindent \dots and, after compiling:

\begin{quote}
<<depicting1i3,dependson='depicting1i',results='asis',echo=FALSE>>=
cat(as.character(A, toLaTeX=TRUE))
@
\end{quote}

\noindent
The code may of course be modified to suit your needs.

\paragraph{Tuning your figures.}
Finally, we leave you with a quite complex example from one of our papers:

<<depicting2a,fig.keep='none'>>=
X <- PiecewiseLinearFuzzyNumber(0, 1, 2, 5, knot.n=1,
   knot.alpha=0.6, knot.left=0.3, knot.right=4)

plot.default(NA, xlab="$x$", ylab="$\\mu_S(x)$",
   xlim=c(-0.3,5.3), ylim=c(0,1)) # empty window

xpos <- c(X["a1"], X["knot.left"],  X["a2"],
          X["a3"], X["knot.right"], X["a4"]);
xlab <- c("$s_1$", "$s_2$", "$s_3$",
          "$s_4$", "$s_5$", "$s_6$");
abline(v=xpos, col="gray", lty=3)
text(xpos, 1.05, xlab, pos=3, xpd=TRUE)

abline(h=c(0, X["knot.alpha"], 1), col="gray", lty=2)
text(5.55, X["knot.alpha"], sprintf("$\\alpha_0$"), pos=4, xpd=TRUE)

plot(X, add=TRUE, type='l', from=-1, to=6)
plot(X, add=TRUE, type='p', from=-1, to=6)
@

\begin{center}
<<depicting2b,dependson='depicting2a',echo=FALSE>>=
X <- PiecewiseLinearFuzzyNumber(0, 1, 2, 5, knot.n=1, knot.alpha=0.6, knot.left=0.3, knot.right=4)

plot.default(NA, xlab="$x$", ylab="$\\mu_S(x)$", xlim=c(-0.3,5.3), ylim=c(0,1))

xpos <- c(X["a1"], X["knot.left"], X["a2"], X["a3"], X["knot.right"], X["a4"]);
xlab <- c("$s_1$", "$s_2$", "$s_3$", "$s_4$", "$s_5$", "$s_6$");
abline(v=xpos, col="gray", lty=3)
text(xpos, 1.05, xlab, pos=3, xpd=TRUE)

abline(h=c(0, X["knot.alpha"], 1), col="gray", lty=2)
text(5.55, X["knot.alpha"], sprintf("$\\alpha_0$"), pos=4, xpd=TRUE)

plot(X, add=TRUE, type='l', from=-1, to=6)
plot(X, add=TRUE, type='p', from=-1, to=6)
@
\end{center}

\noindent
Please note that we use \TeX{} commands in plot labels.
They are interpreted by the \texttt{tikzDevice} package for \R
to generate beautiful figures, but setting this all up requires
higher level of skills\dots and patience.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Basic computations on and characteristics of  fuzzy numbers}


In this section we consider the following FN:

<<comput1a,fig.keep='none'>>=
A <- FuzzyNumber(-5, 3, 6, 20,
    left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@


\subsection{Support and core, and other $\alpha$-cuts}

The support of $A$, i.e.~$\mathrm{supp}(A)=[\mathtt{a1}, \mathtt{a4}]$,
may be obtained by calling:

<<comput1b,dependson='comput1a'>>=
supp(A)
@

\noindent
We get the core of $A$, i.e.~$\mathrm{core}(A)=[\mathtt{a2}, \mathtt{a3}]$,
with:

<<comput1c,dependson='comput1b'>>=
core(A)
@

\noindent
To compute arbitrary $\alpha$-cuts we use:

<<comput1d,dependson='comput1c'>>=
alphacut(A, 0) # same as supp(A) (if alpha-cut generators are defined)
alphacut(A, 1) # same as core(A)
alphacut(A, c(0,0.5,1))
@

\noindent
Note that if we request to compute more than one $\alpha$-cut at once, then
a matrix with 2 columns (instead of a numeric vector of length 2) is returned.
The \texttt{alphacut()} method may only be used when $\alpha$-cut generators are
provided by the user during the declaration of $A$, even for $\alpha=0$
or $\alpha=1$.

\subsection{Evaluation of the membership function}

If side generators are defined, we may calculate
the values of the membership function at different points by calling:

<<comput1e,dependson='comput1d'>>=
evaluate(A, 1)
evaluate(A, c(-3,0,3))
evaluate(A, seq(-1, 2, by=0.5))
@

% \noindent
% As wee see, this method needs a numeric vector (possibly of length 1)
% as its second parameter.


\subsection{``Typical'' value}


Let us first introduce the notion of the \textit{expected interval} of $A$
\cite{DuboisPrade1987}.
\begin{eqnarray}
\mathrm{EI}(A) & := & [\mathrm{EI}_L(A), \mathrm{EI}_U(A)] \\
               & = & \left[ \int_0^1 A_L(\alpha)\,d\alpha, \int_0^1 A_U(\alpha)\,d\alpha \right].
\end{eqnarray}

\noindent
To compute the expected interval of $A$ we call:

<<comput1f,dependson='comput1e'>>=
expectedInterval(A)
@

\noindent
Please note that in case of objects of
the \texttt{FuzzyNumber} class the expected interval is approximated
by numerical integration. This method calls the \texttt{integrate()} function
and its accuracy (quite fine by default)
may be controlled by the \texttt{subdivisions},
\texttt{rel.tol}, and \texttt{abs.tol} parameters
(call \texttt{?integrate} for more details).
On the other hand, for TFNs and PLFs this method returns exact results.

\bigskip
The midpoint of the expected interval is called the \textit{expected value}
of a fuzzy number. It is given by:
\begin{equation}
\mathrm{EV}(A) := \frac{\mathrm{EI}_L(A) + \mathrm{EI}_U(A)}{2}.
\end{equation}

\noindent
Let us calculate $\mathrm{EV}(A)$.

<<comput1g,dependson='comput1f'>>=
expectedValue(A)
@

\noindent
Note that this method uses a call to \texttt{expectedInterval(A)},
thus in case of \texttt{FuzzyNumber} class instances it also uses
numerical approximation.

Sometimes a generalization of the expected value,
called \textit{weighted expected value}, is useful.
For given $w\in[0,1]$ it is defined as:
\begin{equation}
\mathrm{EV}_w(A) := (1-w)\mathrm{EI}_L(A) + w\mathrm{EI}_U(A).
\end{equation}
It is easily seen that $\mathrm{EV}_{0.5}(A)=\mathrm{EV}(A)$.

\noindent
Some examples:

<<comput1h,dependson='comput1g'>>=
weightedExpectedValue(A, 0.5) # equivalent to expectedValue(A)
weightedExpectedValue(A, 0.25)
@

\bigskip
The \textit{value} of $A$ \cite{DelgadoETAL1998} is defined by:
\begin{equation}
\mathrm{val}(A) := \int_0^1 \alpha\left(A_L(\alpha)+A_U(\alpha)\right)\,d\alpha.
\end{equation}

\noindent
It may be calculated by calling:

<<comput1i,dependson='comput1h'>>=
value(A)
@

\noindent
Please note that the expected value or  value
may be used for example to ``defuzzify'' $A$.


\subsection{Measures of ``nonspecificity''}


The \textit{width} of $A$ \cite{Chanas2001} is defined as:
\begin{equation}
\mathrm{width}(A) := \mathrm{EI}_U(A) - \mathrm{EI}_L(A).
\end{equation}

\noindent
An example:

<<comput1j,dependson='comput1i'>>=
width(A)
@

\bigskip
The \textit{ambiguity} of $A$ \cite{DelgadoETAL1998} is defined as:
\begin{equation}
\mathrm{amb}(A) := \int_0^1 \alpha\left(A_U(\alpha)-A_L(\alpha)\right)\,d\alpha.
\end{equation}

<<comput1k,dependson='comput1j'>>=
ambiguity(A)
@

\bigskip
Additionally, to express ``nonspecificity'' of a fuzzy number
we may use e.g.~the width of its support:

<<comput1l,dependson='comput1k'>>=
diff(supp(A))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Arithmetic operations on fuzzy numbers}\label{Sec:Operations}


Let $A,B$ be arbitrary FNs. We define the sum $A+B$  for every
$\alpha \in \lbrack 0,1]$ as:%
\[
\left( A+B\right) _{\alpha }=A_{\alpha }+B_{\alpha }=\left[ A_{L}\left(
\alpha \right) +B_{L}\left( \alpha \right) ,A_{U}\left( \alpha \right)
+B_{U}\left( \alpha \right) \right],
\]%
see \cite{DuboisPrade1978,DiamondKloeden1994}.
Moreover, for $\lambda \in \mathbb{R}$,
the scalar multiplication is given by:
\[
\left( \lambda \cdot A\right) _{\alpha }=\lambda A_{\alpha }=\left\{ 
\begin{array}{ll}
\left[ \lambda A_{L}\left( \alpha \right) ,\lambda A_{U}\left( \alpha
\right) \right] , & \text{if }\lambda \geq 0, \\ 
\left[ \lambda A_{U}\left( \alpha \right) ,\lambda A_{L}\left( \alpha
\right) \right] , & \text{if }\lambda <0,%
\end{array}%
\right. 
\]%
for each $\alpha \in \lbrack 0,1]$.


In \package{FuzzyNumbers}, we have defined
the \texttt{+}, \texttt{-}, and \texttt{*} operators,
which implements the above-mentioned operations.

<<addition>>=
A <- TrapezoidalFuzzyNumber(0, 1, 1, 2)
B <- TrapezoidalFuzzyNumber(1, 2, 2, 3)
plot(A, xlim=c(0,6))
plot(B, add=TRUE, col=2, lty=2)
plot(A+B, add=TRUE, col=4, lty=4)
legend("topright", c("A", "B", "A+B"), lty=c(1,2,4), col=c(1,2,4))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Approximation of fuzzy numbers}\label{Sec:Approximation}


\subsection{Metrics in the space of fuzzy numbers}

It seems that the most suitable metric for approximation problems
is an extension of the Euclidean ($L_2$) distance
(cf.~\cite{Grzegorzewski1998}), $d$, defined by the equation:
\begin{equation}
d^2(A,B) = \int_0^1 \left(A_L(\alpha)-B_L(\alpha)\right)^2\,d\alpha
         + \int_0^1 \left(A_U(\alpha)-B_U(\alpha)\right)^2\,d\alpha.
\end{equation}

% TO BE DONE...

<<TrapDist>>=
T1 <- TrapezoidalFuzzyNumber(-5, 3, 6, 20)
T2 <- TrapezoidalFuzzyNumber(-4, 4, 7, 21)
distance(T1, T2, type='Euclidean') # L2 distance /default/
distance(T1, T2, type='EuclideanSquared') # Squared L2 distance
@

Types available (argument \texttt{type}): \texttt{Euclidean} (default),
\texttt{EuclideanSquared}...





\subsection{Approximation by trapezoidal fuzzy numbers}

TO BE DONE... Problem statement...
%
Given a fuzzy number $A$ we seek for a trapezoidal
fuzzy number $\mathcal{T}(A)$....

In this subsection we will use the following fuzzy number $A$
for the sake of illustration:

<<ApproxExA>>=
A <- FuzzyNumber(-5, 3, 6, 20,
   left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@


\subsubsection{Na\"{i}ve approximation}

The \texttt{"Naive"} method generates a trapezoidal FN with the same
core and support as $A$.

<<ApproxExA_naive,dependson='ApproxExA',fig.keep='none'>>=
(T1 <- trapezoidalApproximation(A, method="Naive"))
distance(A, T1)
@

\begin{center}
<<ApproxExA_naive2,dependson='ApproxExA_naive',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(T1, col="red", lty=2, add=TRUE)
legend('topright', legend=c('$A$', 'Na\\"{i}ve approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}



\subsubsection{$L_2$-nearest approximation}

% $L_2$ distance....

The \texttt{"NearestEuclidean"} method
gives the nearest $L_2$-approximation of $A$
\cite[Corollary 8]{Ban2009}.

% TO BE DONE...

<<ApproxExA_L2n,dependson='ApproxExA',fig.keep='none'>>=
(T2 <- trapezoidalApproximation(A, method="NearestEuclidean"))
distance(A, T2)
@

\begin{center}
<<ApproxExA_naiveL2n2,dependson='ApproxExA_L2n',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(T2, col="red", lty=2, add=TRUE)
legend('topright', legend=c('$A$', '$L_2$-nearest approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}


\subsubsection{Expected interval preserving approximation}


The \texttt{"ExpectedIntervalPreserving"} method
gives the nearest $L_2$-approximation of $A$
preserving the expected interval \cite{Ban2008,Grzegorzewski2010,Yeh2008}.
Note that if $\mathrm{amb}(A) \ge \mathrm{width}(A)/3$, then
we get the same result as in
the \texttt{"NearestEuclidean"} method.

% TO BE DONE...

<<ApproxExA_ExpInt,dependson='ApproxExA',fig.keep='none'>>=
(T3 <- trapezoidalApproximation(A, method="ExpectedIntervalPreserving"))
distance(A, T3)
expectedInterval(A)
expectedInterval(T3)
@

% \begin{center}
<<ApproxExA_ExpInt2,dependson='ApproxExA_ExpInt',eval=FALSE,echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(T3, col="red", lty=2, add=TRUE)
@
% \end{center}

Unfortunately, for highly skewed membership functions this method
(as well as the previous one) reveals sometimes quite unfavorable
behavior. E.g.~if $B$ is a FN such that
$\mathrm{Val}(B) < \mathrm{EV}_{1/3}(B)$
or $\mathrm{Val}(B) > \mathrm{EV}_{2/3}(B)$,
then it may happen that the core of the output
and the core of the original fuzzy number $B$ are disjoint,
cf.~\cite{GrzegorzewskiPasternak2011}.

<<ApproxExA_ExpInt3,fig.keep='none'>>=
(B  <- FuzzyNumber(1, 2, 3, 45,
   lower=function(x) sqrt(x),
   upper=function(x) 1-sqrt(x)))
(TB1 <- trapezoidalApproximation(B, "NearestEuclidean"))
(TB2 <- trapezoidalApproximation(B, "ExpectedIntervalPreserving"))
distance(B, TB1)
distance(B, TB2)
@

\begin{center}
<<ApproxExA_ExpInt3Fig,dependson='ApproxExA_ExpInt3',echo=FALSE>>=
plot(B, xlab="$x$", ylab="$\\alpha$", log='x', xlim=c(0.9,46))
plot(TB1, col="red",  lty=2, add=TRUE)
plot(TB2, col="blue", lty=3, add=TRUE)
legend("topright", c("$\\mu_{B}$", "$\\mu_{TB_1}$", "$\\mu_{TB_2}$"),
   col=c("black", "red", "blue"), lty=c(1,2,3));
@
\end{center}


\subsubsection{Approximation with restrictions on support and core}


The \texttt{"SupportCoreRestricted"} method was proposed in \cite{GrzegorzewskiPasternak2011}.
It gives the $L_2$-nearest trapezoidal approximation with constraints
$\mathrm{core}(A) \subseteq \mathrm{core}(\mathcal{T}(A))$
and $\mathrm{supp}(\mathcal{T}(A)) \subseteq \mathrm{supp}(A)$,
i.e.~for which each point that surely belongs to $A$ also belongs to $\mathcal{T}(A)$,
and each point that surely does not belong to $A$ also does not belong to $\mathcal{T}(A)$.

<<ApproxExA_RestrSuppCore,dependson='ApproxExA',fig.keep='none'>>=
(T4 <- trapezoidalApproximation(A, method="SupportCoreRestricted"))
distance(A, T4)
@

\begin{center}
<<ApproxExA_RestrSuppCore2,dependson='ApproxExA_RestrSuppCore',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(T4, col="red", lty=2, add=TRUE)
legend('topright', legend=c('$A$', 'Supp\\&core restr.\napproximation'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}




\subsection{Approximation by piecewise linear fuzzy numbers}

TO BE DONE... Problem statement... Given a fuzzy number $A$ we seek for a piecewise linear
fuzzy number $\mathcal{P}(A)$....

Currently only fixed \texttt{knot.alpha} allowed.... TO BE DONE....

In this subsection we will use the following fuzzy number $A$
for the sake of illustration:

<<ApproxExAPLFN>>=
A <- FuzzyNumber(-5, 3, 6, 20,
   left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@


\subsubsection{Na\"{i}ve approximation}

The \texttt{"Naive"} method generates a PLFN with the same
core and support as $A$ and with sides interpolating the membership function
of $A$ at given $\alpha$-cuts.

<<ApproxPLFNNaive,dependson='ApproxExAPLFN',fig.keep='none'>>=
P1 <- piecewiseLinearApproximation(A, method="Naive",
         knot.n=1, knot.alpha=0.5)
P1["allknots"]
print(distance(A, P1), 8)
@

\begin{center}
<<ApproxPLFNNaive2,dependson='ApproxPLFNNaive',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(P1, col="red", lty=2, add=TRUE)
legend('topright', legend=c('$A$', 'Na\\"{i}ve approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}


\subsubsection{$L_2$-nearest approximation}

\paragraph{Exact algorithm for fixed \texttt{knot.alpha}.}

TO BE DONE...

For \texttt{knot.n==1} the method proposed in \cite{CoroianuETAL2012}
is used.

<<ApproxPLFNNearest,dependson='ApproxExAPLFN',fig.keep='none'>>=
system.time(P2 <- piecewiseLinearApproximation(A,
   method="NearestEuclidean", knot.n=1, knot.alpha=0.5))
print(P2["allknots"], 6)
print(distance(A, P2), 12)
@

\begin{center}
<<ApproxPLFNNearest2,dependson='ApproxPLFNNearest',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(P2, col="red", lty=2, add=TRUE)
legend('topright', legend=c('$A$', '$L_2$-nearest approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}



\bigskip
Beware of numerical error in integration e.g.~due to discontinuity
in $\alpha$-cuts........
..... TO BE DONE....

<<PLFNApproxNeares_error,fig.keep='none',warning=FALSE>>=
A1 <- FuzzyNumber(0,1,1,1,
         lower=function(a) floor(3*a)/3,
         upper=function(a) 1-a
) # no info on discontinuities

A2 <- DiscontinuousFuzzyNumber(0,1,1,1,
         lower=function(a) floor(3*a)/3,
         upper=function(a) 1-a,
         discontinuities.lower=c(0, 1/3, 2/3, 1),
         discontinuities.upper=numeric(0)
) # discontinuities info included

a <- seq(1e-9, 1-1e-9, length.out=100) # many alphas from (0,1)
d1 <- numeric(length(a)) # distances #1 (to be calculated)
d2 <- numeric(length(a)) # distances #2 (to be calculated)
for (i in 1:length(a))
{
   P1 <- piecewiseLinearApproximation(A1, method="NearestEuclidean",
            knot.n=1, knot.alpha=a[i])
   P2 <- piecewiseLinearApproximation(A2, method="NearestEuclidean",
            knot.n=1, knot.alpha=a[i])

   d1[i] <- distance(A1, P1)
   d2[i] <- distance(A2, P2)
}
@

We note that in the first case the distance for $\alpha=0$ (trapezoidal
approximation) is
smaller than e.g.~for $\alpha\simeq 0.05$, which, theoretically,
is not possible. Moreover, the distance is not continuous
at some $\alpha$ (but it is in theory).
% .. TO DO.....

\begin{center}
<<PLFNApproxNeares_error2,dependson='PLFNApproxNeares_error',echo=FALSE>>=
matplot(a, cbind(d1, d2), type='l', xlab="$\\alpha$", ylab="")
legend("top", c("$d(A_1,P_1)$", "$d(A_2,P_2)$"), lty=c(1,2), col=c(1,2))
@
\end{center}




\paragraph{Finding best \texttt{knot.alpha} numerically.}

Consider the following fuzzy number $A_1$:

<<BestKnotAlphaPLFN>>=
A1 <- FuzzyNumber(0,0,0,1,
   lower=function(a) a,
   upper=function(a) (1-a)^2)
@

Let us depict the $L_2$ distance $D_{A_1}(\alpha)$..........

<<BestKnotAlphaPLFN2,dependson='BestKnotAlphaPLFN',fig.keep='none'>>=
a <- seq(1e-9, 1-1e-9, length.out=100) # many alphas from (0,1)
d <- numeric(length(a)) # distances (to be calculated)
for (i in 1:length(a))
{
   P1 <- piecewiseLinearApproximation(A1, method="NearestEuclidean",
            knot.n=1, knot.alpha=a[i])
   d[i] <- distance(A1, P1)
}
plot(a, d, type='l', xlab=expression(alpha), ylab=expression(D[A](alpha)));
@

\begin{center}
<<BestKnotAlphaPLFN3,dependson='BestKnotAlphaPLFN2',echo=FALSE>>=
plot(a, d, type='l', xlab="$\\alpha$", ylab="$D_{A_1}(\\alpha)$");
@
\end{center}

We may find best \texttt{knot.alpha} using numerical optimization.
We only know that the distance function is continuous.
% TO DO.....


<<BestKnotAlphaPLFN4,dependson='BestKnotAlphaPLFN3',warning=FALSE>>=
for (i in 1:5) # 5 iterations
{
   a0 <- runif(1,0,1); # random starting point
   optim(a0,
      function(a)
      {
         P1 <- piecewiseLinearApproximation(A1, method="NearestEuclidean",
                                             knot.n=1, knot.alpha=a)

         distance(A1, P1);
      }, method="L-BFGS-B", lower=1e-9, upper=1-1e-9) -> res;
   cat(sprintf("%.9f %6g %.9f %.9f\n", a0, res$counts[1], res$par, res$value));
}
@





\paragraph{Approximate algorithm for fixed \texttt{knot.alpha}.}

This method uses a constrained version of the Nelder-Mead algorithm.
The procedure minimizes the target function numerically
by calling the \texttt{optim()} function.
There is thus no guarantee that it will find to the global minimum
(it may fall into a neighborhood of a local minimum
or even fail to converge).
However, this approach may be used for any number of knots.

TO BE DONE... WORK  ON AN EXACT ALGORITHM IS IN PROGRESS.....

<<ApproxMethodPLFN1,dependson='ApproxExAPLFN',fig.keep='none'>>=
system.time(P3 <- piecewiseLinearApproximation(A,
   method="ApproximateNearestEuclidean", knot.n=1, knot.alpha=0.5))
print(P3["allknots"], 6)
print(distance(A, P3), digits=12)
@
\noindent
Compare with exact solution......
Please note that a call to this method may be time-consuming.

Another example:

<<ApproxMethodPLFN2,dependson='ApproxExAPLFN',fig.keep='none'>>=
system.time(P4 <- piecewiseLinearApproximation(A,
   method="ApproximateNearestEuclidean", knot.n=4,
   knot.alpha=c(0.2, 0.3, 0.7, 0.9), verbose=TRUE))
@

\begin{center}
<<ApproxMethodPLFN3,dependson='ApproxMethodPLFN2',echo=FALSE>>=
plot(A, xlab="$x$", ylab="$\\alpha$")
plot(P4, col="red", lty=2, add=TRUE)
print(distance(A, P4), digits=12)
@
\end{center}

If the method fails to converge, you may try to call it
e.g.~with the \texttt{optim.control=list(maxit=\allowbreak{}5000)} parameter
to allow for greater number of iterations.



<<fig.keep='none',echo=FALSE,exec=FALSE>>=
# B <- FuzzyNumber(0, 1, 1, 3,
#    lower=function(x) sqrt(x), upper=function(x) (1-x)^10)
#
# X1 <- piecewiseLinearApproximation(B, knot.n=1, knot.alpha=c(0.5),
#    method="NearestEuclidean", verbose=TRUE)
# round(X1["allknots"],3)
# distance(B, X1)
#
# X2 <- piecewiseLinearApproximation(B,
#    knot.n=1, knot.alpha=c(0.5),
#    method="ApproximateNearestEuclidean",
#    optim.control=list(maxit=5000), verbose=TRUE)
# round(X2["allknots"],3)
# distance(B, X2) # :-(
#
# plot(B, lwd=2)
# plot(X2, add=TRUE, col=4, lty=2)
# plot(X1, add=TRUE, col=2)
# legend("topright",
#    c("Original", "Best PLFN (approximate)", "Best PLFN (exact)"),
#    col=c(1,4,2), lty=c(1,2,1), lwd=c(2,1,1));
@




\section{NEWS/CHANGELOG}

<<NEWSread,comment="",echo=FALSE>>=
cat(readLines("../../NEWS"), sep="\n")
@


\paragraph{Acknowledgments.}
This document has been generated with \LaTeX, \package{knitr} and
the \package{tikzDevice} package for \R.
Their authors' wonderful work is fully appreciated.
Many thanks also to Przemyslaw Grzegorzewski, Lucian Coroianu,
Jan Caha, and Pablo Villacorta Iglesias
for stimulating discussion.



The contribution of Marek Gagolewski was partially supported
by the European Union from resources of the European Social Fund, Project PO KL 
``Information technologies: Research and their interdisciplinary
applications'', agreement UDA-POKL.04.01.01-00-051/10-00 (March-June 2013),
and by FNP START Scholarship from the Foundation for Polish Science (2013).




\begin{thebibliography}{100}
\bibitem{Ban2008}
Ban A.I., Approximation of fuzzy numbers by trapezoidal fuzzy numbers
preserving the expected interval, \textit{Fuzzy Sets and Systems} \textbf{159}, 2008, pp.~1327--1344.

\bibitem{Ban2009}
Ban A.I., On the nearest parametric approximation of a fuzzy
number -- Revisited, \textit{Fuzzy Sets and Systems} \textbf{160}, 2009, pp.~3027--3047.

\bibitem{Chanas2001}
Chanas S., On the interval approximation of a fuzzy number,
\textit{Fuzzy Sets and Systems} \textbf{122}, 2001, pp.~353--356.

\bibitem{CoroianuETAL2012}
Coroianu L., Gagolewski M., Grzegorzewski P.,
\textit{Nearest Piecewise Linear Approximation of Fuzzy Numbers}, 
\textit{Fuzzy Sets and Systems}, 2013, doi:10.1016/j.fss.2013.02.005.

\bibitem{DelgadoETAL1998}
Delgado M., Vila M.A., Voxman W., On a canonical representation of a fuzzy number,
\textit{Fuzzy Sets and Systems} \textbf{93}, 1998, pp.~125--135.

\bibitem{DiamondKloeden1994} P. Diamond, P. Kloeden, Metric Spaces of Fuzzy
Sets. Theory and Applications. World Scientific, Singapore, 1994.

\bibitem{DuboisPrade1978}
Dubois D., Prade H., Operations on fuzzy numbers, \textit{Int. J. Syst. Sci.} \textbf{9}, 1978, pp.~613--626.

\bibitem{DuboisPrade1987}
Dubois D., Prade H., The mean value of a fuzzy number, \textit{Fuzzy Sets and Systems} \textbf{24}, 1987, pp.~279--300.


\bibitem{FuzzyNumbersHome}
Gagolewski M., \package{FuzzyNumbers}: Tools to deal with fuzzy numbers in \R,
\href{http://www.rexamine.com/resources/fuzzynumbers/}{www.rexamine.com/resources/fuzzynumbers/},
2012.

\bibitem{Grzegorzewski1998}
Grzegorzewski P., Metrics and orders in space of fuzzy numbers,
\textit{Fuzzy Sets and Systems} \textbf{97}, 1998, pp.~83--94.

\bibitem{Grzegorzewski2010}
Grzegorzewski P., \textit{Algorithms for trapezoidal approximations of fuzzy numbers
preserving the expected interval}, In: Bouchon-Meunier B. et al (Eds.),
\textit{Foundations of Reasoning Under Uncertainty}, Springer, 2010, pp.~85--98.

\bibitem{GrzegorzewskiPasternak2011}
Grzegorzewski P., Pasternak-Winiarska K., \textit{Trapezoidal approximations of fuzzy numbers
with restrictions on the support and core},
In: \textit{Proc. EUSFLAT/LFA 2011}, Atlantic Press, 2011, pp.~749--756.

\bibitem{KlirYuan1995:fuzzybook}
Klir G.J., Yuan B., \textit{Fuzzy sets and fuzzy logic. {T}heory and applications},
Prentice Hall, New Jersey, 1995.

\bibitem{StefaniniSorini2009:eusflat}
Stefanini L., Sorini L., \textit{Fuzzy arithmetic with parametric LR fuzzy numbers},
In: \textit{Proc. IFSA/EUSFLAT 2009}, pp.~600--605.

\bibitem{Yeh2008}
Yeh C.-T., Trapezoidal and triangular approximations preserving the expected interval,
\textit{Fuzzy Sets and Systems} \textbf{159}, 2008, pp.~1345--1353.
\end{thebibliography}


\end{document}
